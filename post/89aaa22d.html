<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java虚拟机-JVM | Syerenc</title><meta name="keywords" content="java jvm"><meta name="author" content="lcq"><meta name="copyright" content="lcq"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JVM原理">
<meta property="og:type" content="article">
<meta property="og:title" content="Java虚拟机-JVM">
<meta property="og:url" content="http://example.com/post/89aaa22d.html">
<meta property="og:site_name" content="Syerenc">
<meta property="og:description" content="JVM原理">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://iw233.cn/api.php?sort=pc">
<meta property="article:published_time" content="2022-08-18T06:11:17.000Z">
<meta property="article:modified_time" content="2022-08-30T06:38:04.422Z">
<meta property="article:author" content="lcq">
<meta property="article:tag" content="java jvm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://iw233.cn/api.php?sort=pc"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/post/89aaa22d"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java虚拟机-JVM',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-08-30 14:38:04'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/source/css/jianbian.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"> <script src="/live2d-widget/autoload.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">28</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">13</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://iw233.cn/api.php?sort=pc')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Syerenc</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java虚拟机-JVM</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-08-18T06:11:17.000Z" title="Created 2022-08-18 14:11:17">2022-08-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-08-30T06:38:04.422Z" title="Updated 2022-08-30 14:38:04">2022-08-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%AD%A6%E4%B9%A0%E4%B8%BB%E7%BA%BF/">Java学习主线</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">23.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>81min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java虚拟机-JVM"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h1 id="一、JVM概述"><a href="#一、JVM概述" class="headerlink" title="一、JVM概述"></a>一、JVM概述</h1><p>Java程序之所以能够实现跨平台，本质就是因为它是运行在虚拟机之上的，而不同平台只需要安装对应平台的Java虚拟机即可运行（在JRE中包含），所有的Java程序都采用统一的标准，在任何平台编译出来的字节码文件(.class)也是同样的，最后实际上是将编译后的字节码交给JVM处理执行。</p>
<h3 id="技术概述"><a href="#技术概述" class="headerlink" title="技术概述"></a>技术概述</h3><p>首先我们要了解虚拟机的具体定义，我们所接触过的虚拟机有安装操作系统的虚拟机，也有我们的Java虚拟机，而它们所面向的对象不同，Java虚拟机只是面向单一应用程序的虚拟机，但是它和我们接触的系统级虚拟机一样，我们也可以为其分配实际的硬件资源，比如最大内存大小等。</p>
<p>并且Java虚拟机并没有采用传统的PC架构，比如现在的HotSpot虚拟机，实际上采用的是<code>基于栈的指令集架构</code>，而我们的传统程序设计一般都是<code>基于寄存器的指令集架构</code>。</p>
<p>在不同的CPU架构下，实际上得到的汇编代码也不一样，并且<u>在arm架构下并没有和x86架构一样的寄存器结构</u>，因此只能使用不同的汇编指令操作来实现。所以这也是为什么C语言不支持跨平台的原因，我们只能将同样的代码在不同的平台上编译之后才能在对应的平台上运行我们的程序。而Java利用了JVM，它提供了很好的平台无关性（当然，JVM本身是不跨平台的），我们的Java程序编译之后，并不是可以由平台直接运行的程序，而是由JVM运行，同时，我们前面说了，JVM（如HotSpot虚拟机），实际上采用的是<code>基于栈的指令集架构</code>，它并<u>没有依赖于寄存器，而是更多的利用操作栈来完成</u>，这样不仅设计和实现起来更简单，并且也能够更加方便地实现跨平台，不太依赖于硬件的支持。</p>
<h3 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h3><p>这里我们对一个类进行反编译查看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>&#123;    <span class="comment">//和上面的例子一样</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v target/classes/com/test/Main.class <span class="comment">#使用javap命令对class文件进行反编译</span></span><br></pre></td></tr></table></figure>

<p>得到如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">public int test();</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=4, args_size=1</span><br><span class="line">         0: bipush        10</span><br><span class="line">         2: istore_1</span><br><span class="line">         3: bipush        20</span><br><span class="line">         5: istore_2</span><br><span class="line">         6: iload_1</span><br><span class="line">         7: iload_2</span><br><span class="line">         8: iadd</span><br><span class="line">         9: istore_3</span><br><span class="line">        10: iload_3</span><br><span class="line">        11: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 5: 0</span><br><span class="line">        line 6: 3</span><br><span class="line">        line 7: 6</span><br><span class="line">        line 8: 10</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      12     0  this   Lcom/test/Main;</span><br><span class="line">            3       9     1     a   I</span><br><span class="line">            6       6     2     b   I</span><br><span class="line">           10       2     3     c   I</span><br></pre></td></tr></table></figure>

<p>我们可以看到，java文件编译之后，也会生成类似于C语言那样的汇编指令，但是这些命令都是交给JVM去执行的命令（实际上虚拟机提供了一个类似于物理机的运行环境，也有程序计数器之类的东西），最下方存放的是本地变量（局部变量）表，表示此方法中出现的本地变量，实际上this也在其中，所以我们才能在非静态方法中使用<code>this</code>关键字，在最上方标记了方法的返回值类型、访问权限等。首先介绍一下例子中出现的命令代表什么意思：</p>
<ul>
<li>bipush   将单字节的常量值推到栈顶</li>
<li>istore_1   将栈顶的int类型数值存入到第二个本地变量</li>
<li>istore_2   将栈顶的int类型数值存入到第三个本地变量</li>
<li>istore_3   将栈顶的int类型数值存入到第四个本地变量</li>
<li>iload_1    将第二个本地变量推向栈顶</li>
<li>iload_2    将第三个本地变量推向栈顶</li>
<li>iload_3   将第四个本地变量推向栈顶</li>
<li>iadd   将栈顶的两个int类型变量相加，并将结果压入栈顶</li>
<li>ireturn   方法的返回操作</li>
</ul>
<p>JVM运行字节码时，所有的操作基本都是围绕两种数据结构，一种是堆栈（本质是栈结构），还有一种是队列，如果JVM执行某条指令时，该指令需要对数据进行操作，那么<strong>被操作的数据在指令执行前，必须要压到堆栈上，JVM会自动将栈顶数据作为操作数</strong>。如果堆栈上的数据需要暂时保存起来时，那么它就会被存储到局部变量队列上。</p>
<p>我们从第一条指令来依次向下解读，显示方法相关属性：</p>
<pre><code>descriptor: ()I     //参数以及返回值类型，()I就表示没有形式参数，返回值为基本类型int
flags: ACC_PUBLIC   //public访问权限
Code:
  stack=2, locals=4, args_size=1    //stack表示要用到的最大栈深度，本地变量数，堆栈上最大对象数量（这里指的是this）
</code></pre>
<p>有关descriptor的详细属性介绍，我们会放在之后的类结构中进行讲解。</p>
<p>接着我们来看指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0: bipush        10     //0是程序偏移地址，然后是指令，最后是操作数</span><br><span class="line">2: istore_1</span><br></pre></td></tr></table></figure>

<p>这一步操作实际上就是使用<code>bipush</code>将10推向栈顶，接着使用<code>istore_1</code>将当前栈顶数据存放到第二个局部变量中，也就是a，所以这一步执行的是<code>int a = 10</code>操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3: bipush        20</span><br><span class="line">5: istore_2</span><br></pre></td></tr></table></figure>

<p>同上，这里执行的是<code>int b = 20</code>操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">6: iload_1</span><br><span class="line">7: iload_2</span><br><span class="line">8: iadd</span><br></pre></td></tr></table></figure>

<p>这里是将第二和第三个局部变量放到栈中，也就是取a和b的值到栈中，最后<code>iadd</code>操作将栈中的两个值相加，结果依然放在栈顶。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">9: istore_3</span><br><span class="line">10: iload_3</span><br><span class="line">11: ireturn</span><br></pre></td></tr></table></figure>

<p>将栈顶数据存放到第四个局部变量中，也就是c，执行的是<code>int c = 30</code>，最后取出c的值放入栈顶，使用<code>ireturn</code>返回栈顶值，也就是方法的返回值。</p>
<p>至此，方法执行完毕。</p>
<p>实际上我们发现，JVM执行的命令基本都是入栈出栈等，而且大部分指令都是没有操作数的，传统的汇编指令有一操作数、二操作数甚至三操作数的指令，Java相比C编译出来的汇编指令，执行起来会更加复杂，实现某个功能的指令条数也会更多，所以Java的执行效率实际上是不如C/C++的，虽然能够很方便地实现跨平台，但是性能上大打折扣，所以在性能要求比较苛刻的Android上，采用的是定制版的JVM，并且是基于寄存器的指令集架构。此外，在某些情况下，我们还可以使用JNI机制来通过Java调用C/C++编写的程序以提升性能（也就是本地方法，使用到native关键字）</p>
<hr>
<h3 id="虚拟机的发展历程"><a href="#虚拟机的发展历程" class="headerlink" title="虚拟机的发展历程"></a>虚拟机的发展历程</h3><p>在1996，Java1.0面世时，第一款商用虚拟机Sun Classic VM开始了它的使命，这款虚拟机提供了一个Java解释器，也就是将我们的class文件进行读取，最后像上面一样得到一条一条的命令，JVM再将指令依次执行。虽然这样的运行方式非常的简单易懂，但是它的效率实际上是很低的，就像你耳机里一边在放六级听力，你必须同时记在脑海里面然后等着问问题，再去选择问题的答案一样，更重要的是同样的代码每次都需要重新翻译再执行。</p>
<p>这个时候我们就需要更加高效的方式来运行Java程序，随着后面的发展，现在大多数的主流的JVM都包含<strong>即时编译器</strong>。JVM会根据当前代码的进行判断，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为“热点代码”。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器（Just In Time compiler，JIT）</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/955092-20191118100603404-2016014845.jpg" alt="img"></p>
<p>在JDK1.4时，Sun Classic VM完全退出了历史舞台，取而代之的是至今都在使用的HotSpot VM，它是目前使用最广泛的虚拟机，拥有上面所说的热点代码探测技术、准确式内存管理（虚拟机可以知道内存中某个位置的数据具体是什么类型）等技术，而我们之后的章节都是基于HotSpot虚拟机进行讲解。</p>
<h3 id="虚拟机发展的未来"><a href="#虚拟机发展的未来" class="headerlink" title="虚拟机发展的未来"></a>虚拟机发展的未来</h3><p>2018年4月，Oracle Labs公开了最新的GraalVM，它是一种全新的虚拟机，它能够实现所有的语言统一运行在虚拟机中。</p>
<p>Graal VM被官方称为“Universal VM”和“Polyglot VM”，这是一个在HotSpot虚拟机基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言”的运行平台使用，这里“任何语言”包括了Java、Scala、Groovy、Kotlin等基于Java虚拟机之上的语言，还包括了C、C++、Rust等基于LLVM的语言，同时支持其他像JavaScript、Ruby、Python和R语言等等。Graal VM可以无额外开销地混合使用这些编程语言，支持不同语言中混用对方的接口和对象，也能够支持这些语言使用已经编写好的本地库文件。</p>
<p>Graal VM的基本工作原理是将这些语言的源代码（例如JavaScript）或源代码编译后的中间格式（例如LLVM字节码）通过解释器转换为能被Graal VM接受的中间表示（Intermediate Representation，IR），譬如设计一个解释器专门对LLVM输出的字节码进行转换来支持C和C++语言，这个过程称为“程序特化”（Specialized，也常称为Partial Evaluation）。Graal VM提供了Truffle工具集来快速构建面向一种新语言的解释器，并用它构建了一个称为Sulong的高性能LLVM字节码解释器。</p>
<hr>
<h3 id="JVM启动流程探究"><a href="#JVM启动流程探究" class="headerlink" title="JVM启动流程探究"></a>JVM启动流程探究</h3><p>前面我们完成了JDK8的编译，也了解了如何进行断点调试，现在我们就可以来研究一下JVM的启动流程了，首先我们要明确，虚拟机的启动入口位于<code>jdk/src/share/bin/java.c</code>的<code>JLI_Launch</code>函数，整个流程分为如下几个步骤：</p>
<ol>
<li>配置JVM装载环境</li>
<li>解析虚拟机参数</li>
<li>设置线程栈大小</li>
<li>执行JavaMain方法</li>
</ol>
<p>首先我们来看看<code>JLI_Launch</code>函数是如何定义的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">JLI_Launch</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv,              <span class="comment">/* main argc, argc */</span></span></span><br><span class="line"><span class="params">        <span class="type">int</span> jargc, <span class="type">const</span> <span class="type">char</span>** jargv,          <span class="comment">/* java args */</span></span></span><br><span class="line"><span class="params">        <span class="type">int</span> appclassc, <span class="type">const</span> <span class="type">char</span>** appclassv,  <span class="comment">/* app classpath */</span></span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">char</span>* fullversion,                <span class="comment">/* full version defined */</span></span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">char</span>* dotversion,                 <span class="comment">/* dot version defined */</span></span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">char</span>* pname,                      <span class="comment">/* program name */</span></span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">char</span>* lname,                      <span class="comment">/* launcher name */</span></span></span><br><span class="line"><span class="params">        jboolean javaargs,                      <span class="comment">/* JAVA_ARGS */</span></span></span><br><span class="line"><span class="params">        jboolean cpwildcard,                    <span class="comment">/* classpath wildcard */</span></span></span><br><span class="line"><span class="params">        jboolean javaw,                         <span class="comment">/* windows-only javaw */</span></span></span><br><span class="line"><span class="params">        jint     ergo_class                     <span class="comment">/* ergnomics policy */</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>可以看到在入口点的参数有很多个，其中包括当前的完整版本名称、简短版本名称、运行参数、程序名称、启动器名称等。</p>
<p>首先会进行一些初始化操作以及Debug信息打印配置等：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">InitLauncher(javaw);</span><br><span class="line">DumpState();</span><br><span class="line"><span class="keyword">if</span> (JLI_IsTraceLauncher()) &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Command line args:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc ; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;argv[%d] = %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    AddOption(<span class="string">&quot;-Dsun.java.launcher.diag=true&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着就是选择一个合适的JRE版本：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Make sure the specified version of the JRE is running......</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SelectVersion(argc, argv, &amp;main_class);</span><br></pre></td></tr></table></figure>

<p>接着是创建JVM执行环境，例如需要确定数据模型，是32位还是64位，以及jvm本身的一些配置在jvm.cfg文件中读取和解析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CreateExecutionEnvironment(&amp;argc, &amp;argv,</span><br><span class="line">                               jrepath, <span class="keyword">sizeof</span>(jrepath),</span><br><span class="line">                               jvmpath, <span class="keyword">sizeof</span>(jvmpath),</span><br><span class="line">                               jvmcfg,  <span class="keyword">sizeof</span>(jvmcfg));</span><br></pre></td></tr></table></figure>

<p>此函数只在头文件中定义，具体的实现是根据不同平台而定的。接着会动态加载jvm.so这个共享库，并把jvm.so中的相关函数导出并且初始化，而启动JVM的函数也在其中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!LoadJavaVM(jvmpath, &amp;ifn)) &#123;</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后就是对JVM进行初始化了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> JVMInit(&amp;ifn, threadStackSize, argc, argv, mode, what, ret);</span><br></pre></td></tr></table></figure>

<p>这也是由平台决定的，比如Mac下的实现为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">JVMInit</span><span class="params">(InvocationFunctions* ifn, jlong threadStackSize,</span></span><br><span class="line"><span class="params">                 <span class="type">int</span> argc, <span class="type">char</span> **argv,</span></span><br><span class="line"><span class="params">                 <span class="type">int</span> mode, <span class="type">char</span> *what, <span class="type">int</span> ret)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sameThread) &#123;</span><br><span class="line">        <span class="comment">//无需关心....</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">//正常情况下走这个</span></span><br><span class="line">        <span class="keyword">return</span> ContinueInNewThread(ifn, threadStackSize, argc, argv, mode, what, ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到最后进入了一个<code>ContinueInNewThread</code>函数，这个函数会创建一个新的线程来执行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">ContinueInNewThread</span><span class="params">(InvocationFunctions* ifn, jlong threadStackSize,</span></span><br><span class="line"><span class="params">                    <span class="type">int</span> argc, <span class="type">char</span> **argv,</span></span><br><span class="line"><span class="params">                    <span class="type">int</span> mode, <span class="type">char</span> *what, <span class="type">int</span> ret)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">      rslt = ContinueInNewThread0(JavaMain, threadStackSize, (<span class="type">void</span>*)&amp;args);</span><br><span class="line">      <span class="keyword">return</span> (ret != <span class="number">0</span>) ? ret : rslt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着进入了一个名为<code>ContinueInNewThread0</code>的函数，可以看到它将<code>JavaMain</code>函数传入作为参数，而此函数定义的第一个参数类型是一个函数指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">ContinueInNewThread0</span><span class="params">(<span class="type">int</span> (JNICALL *continuation)(<span class="type">void</span> *), jlong stack_size, <span class="type">void</span> * args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> rslt;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">pthread_attr_t</span> attr;</span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stack_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      pthread_attr_setstacksize(&amp;attr, stack_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;tid, &amp;attr, (<span class="type">void</span> *(*)(<span class="type">void</span>*))continuation, (<span class="type">void</span>*)args) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="type">void</span> * tmp;</span><br><span class="line">      pthread_join(tid, &amp;tmp);</span><br><span class="line">      rslt = (<span class="type">int</span>)tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * Continue execution in current thread if for some reason (e.g. out of</span></span><br><span class="line"><span class="comment">      * memory/LWP)  a new thread can&#x27;t be created. This will likely fail</span></span><br><span class="line"><span class="comment">      * later in continuation as JNI_CreateJavaVM needs to create quite a</span></span><br><span class="line"><span class="comment">      * few new threads, anyway, just give it a try..</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      rslt = continuation(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line">    <span class="keyword">return</span> rslt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后实际上是在新的线程中执行<code>JavaMain</code>函数，最后我们再来看看此函数里面做了什么事情：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Initialize the virtual machine */</span></span><br><span class="line">start = CounterGet();</span><br><span class="line"><span class="keyword">if</span> (!InitializeJVM(&amp;vm, &amp;env, &amp;ifn)) &#123;</span><br><span class="line">    JLI_ReportErrorMessage(JVM_ERROR1);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一步初始化虚拟机，如果报错直接退出。接着就是加载主类（至于具体如何加载一个类，我们会放在后面进行讲解），因为主类是我们Java程序的入口点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mainClass = LoadMainClass(env, mode, what);</span><br></pre></td></tr></table></figure>

<p>某些没有主方法的Java程序比如JavaFX应用，会获取ApplicationMainClass：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appClass = GetApplicationClass(env);</span><br></pre></td></tr></table></figure>

<p>初始化完成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PostJVMInit(env, appClass, vm);</span><br></pre></td></tr></table></figure>

<p>接着就是获取主类中的主方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mainID = (*env)-&gt;GetStaticMethodID(env, mainClass, <span class="string">&quot;main&quot;</span>,</span><br><span class="line">                                   <span class="string">&quot;([Ljava/lang/String;)V&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>没错，在字节码中<code>void main(String[] args)</code>表示为<code>([Ljava/lang/String;)V</code>我们之后会详细介绍。接着就是调用主方法了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Invoke main method. */</span></span><br><span class="line">(*env)-&gt;CallStaticVoidMethod(env, mainClass, mainID, mainArgs);</span><br></pre></td></tr></table></figure>

<p>调用后，我们的Java程序就开飞速运行起来，直到走到主方法的最后一行返回：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The launcher&#x27;s exit code (in the absence of calls to</span></span><br><span class="line"><span class="comment"> * System.exit) will be non-zero if main threw an exception.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ret = (*env)-&gt;ExceptionOccurred(env) == <span class="literal">NULL</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">LEAVE();</span><br></pre></td></tr></table></figure>

<p>至此，一个Java程序的运行流程结束，在最后LEAVE函数中会销毁JVM。我们可以进行断点调试来查看是否和我们推出的结论一致：</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/008i3skNly1gyux4uqcxpj31sr0u0td4.jpg" alt="image-20220129211342240"></p>
<p>还是以我们之前编写的测试类进行，首先来到调用之前，我们看到主方法执行之前，控制台没有输出任何内容，接着我们执行此函数，再来观察控制台的变化：</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/008i3skNly1gyux4w5322j31zt0u0afp.jpg" alt="image-20220129211450939"></p>
<p>可以看到，主方法执行完成之后，控制台也成功输出了Hello World！</p>
<p>继续下一步，整个Java程序执行完成，得到退出状态码<code>0</code>：</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/008i3skNly1gyux4ydghaj31bk0eimy7.jpg" alt="image-20220129211540210"></p>
<p>成功验证。</p>
<h3 id="一图总结JVM启动执行过程"><a href="#一图总结JVM启动执行过程" class="headerlink" title="一图总结JVM启动执行过程"></a>一图总结JVM启动执行过程</h3><p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/008i3skNly1gyux50ahdrj31d30u0tdu.jpg" alt="image-20220129213143973"></p>
<hr>
<h3 id="JNI-调用本地方法"><a href="#JNI-调用本地方法" class="headerlink" title="JNI 调用本地方法"></a>JNI 调用本地方法</h3><p>Java还有一个JNI机制，它的全称：Java Native Interface，即Java本地接口。它允许在Java虚拟机内运行的Java代码与其他编程语言（如C/C++和汇编语言）编写的程序和库进行交互（在Android开发中用得比较多）比如我们现在想要让C语言程序帮助我们的Java程序实现a+b的运算，首先我们需要创建一个本地方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(sum(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//本地方法使用native关键字标记，无需任何实现，交给C语言实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建好后，接着点击构建按钮，会出现一个out文件夹，也就是生成的class文件在其中，接着我们直接生成对应的C头文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javah -classpath out/production/SimpleHelloWorld -d ./jni com.test.Main</span><br></pre></td></tr></table></figure>

<p>生成的头文件位于jni文件夹下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Header for class com_test_Main */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _Included_com_test_Main</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Included_com_test_Main</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     com_test_Main</span></span><br><span class="line"><span class="comment"> * Method:    sum</span></span><br><span class="line"><span class="comment"> * Signature: (II)V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT <span class="type">void</span> JNICALL <span class="title function_">Java_com_test_Main_sum</span></span><br><span class="line">  <span class="params">(JNIEnv *, jclass, jint, jint)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>接着我们在CLion中新建一个C++项目，并引入刚刚生成的头文件，并导入jni相关头文件（在JDK文件夹中）首先修改CMake文件：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.21</span>)</span><br><span class="line"><span class="keyword">project</span>(JNITest)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(/Library/Java/JavaVirtualMachines/zulu-<span class="number">8</span>.jdk/Contents/Home/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">include_directories</span>(/Library/Java/JavaVirtualMachines/zulu-<span class="number">8</span>.jdk/Contents/Home/<span class="keyword">include</span>/darwin)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(JNITest com_test_Main.cpp com_test_Main.h)</span><br></pre></td></tr></table></figure>

<p>接着就可以编写实现了，首先认识一下引用类型对照表：</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/008i3skNly1gyux540wn7j30xc0h1q47.jpg" alt="img"></p>
<p>所以我们这里直接返回a+b即可：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;com_test_Main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jint JNICALL <span class="title">Java_com_test_Main_sum</span></span></span><br><span class="line"><span class="function">        <span class="params">(JNIEnv * env, jclass clazz, jint a, jint b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们就可以将cpp编译为动态链接库，在MacOS下会生成<code>.dylib</code>文件，Windows下会生成<code>.dll</code>文件，我们这里就只以MacOS为例，命令有点长，因为还需要包含JDK目录下的头文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc com_test_Main.cpp -I /Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home/include -I /Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home/include/darwin -fPIC -shared -o test.dylib -lstdc++</span><br></pre></td></tr></table></figure>

<p>编译完成后，得到<code>test.dylib</code>文件，这就是动态链接库了。</p>
<p>最后我们再将其放到桌面，然后在Java程序中加载：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.load(<span class="string">&quot;/Users/nagocoler/Desktop/test.dylib&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(sum(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行，成功得到结果：</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/008i3skNly1gyux58pg32j31ag0smjv5.jpg" alt="image-20220129222858105"></p>
<p>通过了解JVM的一些基础知识，我们心目中大致有了一个JVM的模型，在下一章，我们将继续深入学习JVM的内存管理机制和垃圾收集器机制，以及一些实用工具。</p>
<hr>
<h1 id="二、JVM内存管理"><a href="#二、JVM内存管理" class="headerlink" title="二、JVM内存管理"></a>二、JVM内存管理</h1><p>在传统的C/C++开发中，经常通过使用申请内存的方式来创建对象或是存放某些数据，但是这样也带来了一些额外的问题，我们要在何时释放这些内存，怎么才能使得内存的使用最高效，因此，内存管理是一个非常严肃的问题。比如我们就可以通过C语言动态申请内存，并用于存放数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//动态申请4个int大小的内存空间</span></span><br><span class="line">    <span class="type">int</span>* memory = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//修改第一个int空间的值</span></span><br><span class="line">    memory[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//修改第二个int空间的值</span></span><br><span class="line">    memory[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//遍历内存区域中所有的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, memory[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放指针所指向的内存区域</span></span><br><span class="line">    <span class="built_in">free</span>(memory);</span><br><span class="line">    <span class="comment">//最后将指针赋值为NULL</span></span><br><span class="line">    memory = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在Java中，这种操作实际上是不允许的，Java只支持直接使用基本数据类型和对象类型，至于内存到底如何分配，并不是由我们来处理，而是JVM帮助我们进行控制，这样就帮助我们节省很多内存上的工作，虽然带来了很大的便利，但是，一旦出现内存问题，我们就无法像C/C++那样对所管理的内存进行合理地处理，因为所有的内存操作都是由JVM在进行，只有了解了JVM的内存管理机制，我们才能够在出现内存相关问题时找到解决方案。</p>
<h2 id="内存区域划分"><a href="#内存区域划分" class="headerlink" title="内存区域划分"></a>内存区域划分</h2><p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/img2018.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg" alt="点击查看图片来源"></p>
<p>内存区域一共分为5个区域，其中方法区和堆是所有线程共享的区域，随着虚拟机的创建而创建，虚拟机的结束而销毁，而虚拟机栈、本地方法栈、程序计数器都是线程之间相互隔离的，每个线程都有一个自己的区域，并且线程启动时会自动创建，结束之后会自动销毁。内存划分完成之后，我们的JVM执行引擎和本地库接口，也就是Java程序开始运行之后就会根据分区合理地使用对应区域的内存了。</p>
<h3 id="大致划分"><a href="#大致划分" class="headerlink" title="大致划分"></a>大致划分</h3><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器和传统8086 CPU中PC寄存器的工作差不多，因为JVM虚拟机目的就是实现物理机那样的程序执行。在8086 CPU中，PC作为程序计数器，负责储存内存地址，该地址指向下一条即将执行的指令，每解释执行完一条指令，PC寄存器的值就会自动被更新为下一条指令的地址。</p>
<p>而JVM中的程序计数器可以看做是<strong>当前线程所执行字节码的行号指示器</strong>，而行号正好就指的是某一条指令，字节码解释器在工作时也会改变这个值，来指定下一条即将执行的指令。</p>
<p>因为Java的多线程也是依靠时间片轮转算法进行的，因此一个CPU同一时间也只会处理一个线程，当某个线程的时间片消耗完成后，会自动切换到下一个线程继续执行，而当前线程的执行位置会被保存到当前线程的程序计数器中，当下次轮转到此线程时，又继续根据之前的执行位置继续向下执行。</p>
<p>记录虚拟机正在执行的字节码指令的地址（如果正在执行的是本地方法则为空，之所以为空是因为本地方法都是C或者C++语言编写的，执行过程不受JVM的监控）。</p>
<blockquote>
<p>主要作用： </p>
<p>实现代码的流程控制；</p>
<p>方便线程切换后恢复现场</p>
</blockquote>
<p>注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p>
<h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>虚拟机栈就是一个非常关键的部分，看名字就知道它是一个栈结构，每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（其实就是栈里面的一个元素），栈帧中包括了当前方法的一些信息，比如局部变量表、操作数栈、动态链接、方法出口等。</p>
<img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/008i3skNly1gywoc0w7ouj30xm0hy401.jpg" alt="image-20220131110349472" style="zoom:67%;" />

<p>（1）局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。局部变量表所需的内存空间在编译时期完成分配。</p>
<p>（2）操作数栈就是我们之前字节码执行时使用到的栈结构； </p>
<p>（3）每个栈帧还保存了一个<strong>可以指向当前方法所在类</strong>的运行时常量池，目的是：<strong>当前方法中如果需要调用其他方法的时候，能够从运行时常量池中找到对应的符号引用，然后将符号引用转换为直接引用，然后就能直接调用对应方法，这就是动态链接</strong>，最后是方法出口，也就是方法该如何结束，是抛出异常还是正常返回。</p>
<p>另外，可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.4 中默认为 256K，而在 JDK1.5+ 为 1M：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xss2M HackTheJava</span><br></pre></td></tr></table></figure>



<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。本地方法执行是在os中执行的，并非在JVM中执行的，所以使用的是os的程序计数器而非JVM的程序计数器。</p>
<p>虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。</p>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>所有对象都在这里分配内存，是垃圾收集的主要区域（”GC 堆”）。</p>
<p>堆是被线程共享的一块内存区域，创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行垃圾收集的最重要的内存区域。由于现代 VM 采用分代收集算法, 因此 Java 堆从 GC 的角度还可以细分为：新生代(Eden 区 、 From Survivor 区 和 To Survivor 区 )和老年代。进一步划分的目的是更好地回收内存，或者更快地分配内存。</p>
<blockquote>
<p> JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p>
</blockquote>
<p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，之后每进行一次垃圾回收，它的年龄就加一，在s1 和 s0之间来回倒腾，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。</p>
<p>堆可以不需要连续内存（现在堆内存的结构可能是一块块的堆内存通过链表连接起来，哪块需要回收就回收哪块），并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。</p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区也是整个Java应用程序共享的区域，它用于存储<strong>所有的类信息、常量、静态变量、动态编译缓存</strong>等数据，可以大致分为两个部分，一个是类信息表，一个是运行时常量池。方法区也是我们要重点介绍的部分。</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/008i3skNly1gyxz722qmjj31520mmgo9.jpg" alt="image-20220201140516096"></p>
<p>首先类信息表中存放的是当前应用程序加载的所有类信息，包括<strong>类的版本、字段、方法、接口</strong>等信息，同时会将编译时生成的常量池数据全部存放到运行时常量池中。当然，常量也并不是只能从类信息中获取，在程序运行时，也有可能会有新的常量进入到常量池。</p>
<p>其实我们的String类正是利用了常量池进行优化：字符串常量池。在JDK1.7之后，稍微有一些区别，在调用<code>intern()</code>方法时，当常量池中没有对应的字符串时，不会再进行复制操作，而是将其直接修改为指向当前字符串堆中的的引用。</p>
<p>值得注意的是，在JDK7之后，字符串常量池从方法区移动到了堆中。</p>
<h4 id="总结各个内存区域的用途"><a href="#总结各个内存区域的用途" class="headerlink" title="总结各个内存区域的用途"></a>总结各个内存区域的用途</h4><ul>
<li>（线程独有）程序计数器：保存当前程序的执行位置。</li>
<li>（线程独有）虚拟机栈：通过栈帧来维持方法调用顺序，帮助控制程序有序运行。</li>
<li>（线程独有）本地方法栈：同上，作用与本地方法。</li>
<li>堆：所有的对象和数组都在这里保存。</li>
<li>方法区：类信息、即时编译器的代码缓存、运行时常量池。</li>
</ul>
<p>当然，这些内存区域划分仅仅是概念上的，具体的实现过程我们后面还会提到。</p>
<hr>
<h3 id="爆内存和爆栈"><a href="#爆内存和爆栈" class="headerlink" title="爆内存和爆栈"></a>爆内存和爆栈</h3><blockquote>
<p>Java 虚拟机栈会出现两种错误：StackOverFlowError 和 OutOfMemoryError。</p>
<p>StackOverFlowError： 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。</p>
<p>OutOfMemoryError： 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError 错误。</p>
</blockquote>
<p>实际上，在Java程序运行时，内存容量不可能是无限制的，当我们的对象创建过多或是数组容量过大时，就会导致我们的堆内存不足以存放更多新的对象或是数组，这时就会出现错误，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[Integer.MAX_VALUE];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们申请了一个容量为21亿多的int型数组，显然，如此之大的数组不可能放在我们的堆内存中，所以程序运行时就会这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Requested array size exceeds VM limit</span><br><span class="line">	at com.test.Main.main(Main.java:<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>这里得到了一个<code>OutOfMemoryError</code>错误，也就是我们常说的内存溢出错误。我们可以通过参数（Run-&gt;Edit Configuration -&gt; modify options -&gt; Add VM options）来控制堆内存的最大值和最小值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms最小值 -Xmx最大值</span><br></pre></td></tr></table></figure>

<p>比如我们现在限制堆内存为固定值1M大小，并且在抛出内存溢出异常时保存当前的内存堆转储快照：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms1m -Xmx1m -XX:+HeapDumpOnOutOfMemoryError</span><br></pre></td></tr></table></figure>

<img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/image-20220828230323958.png" alt="image-20220828230323958" style="zoom:80%;" />

<p>注意堆内存不要设置太小，不然连虚拟机都不足以启动，接着编写一个一定会导致内存溢出的程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Test&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Test</span>());    <span class="comment">//无限创建Test对象并丢进List中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在程序运行之后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to java_pid35172.hprof ...</span><br><span class="line">Heap dump file created [12895344 bytes in 0.028 secs]</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at java.util.Arrays.copyOf(Arrays.java:3210)</span><br><span class="line">	at java.util.Arrays.copyOf(Arrays.java:3181)</span><br><span class="line">	at java.util.ArrayList.grow(ArrayList.java:267)</span><br><span class="line">	at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:241)</span><br><span class="line">	at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:233)</span><br><span class="line">	at java.util.ArrayList.add(ArrayList.java:464)</span><br><span class="line">	at com.test.Main.main(Main.java:10)</span><br></pre></td></tr></table></figure>

<p>可以看到错误出现原因正是<code>Java heap space</code>，也就是堆内存满了，并且根据我们设定的VM参数，堆内存保存了快照信息。我们可以在IDEA内置的Profiler中进行查看：</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/008i3skNly1gyyaddef66j31vo0u0jwq.jpg" alt="image-20220201203157213"></p>
<p>可以很明显地看到，在创建了360146个Test对象之后，堆内存蚌埠住了，于是就抛出了内存溢出错误。</p>
<p>我们接着来看栈溢出，我们知道，虚拟机栈会在方法调用时插入栈帧，那么，设想如果出现无限递归的情况呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这很明显是一个永无休止的程序，并且会不断继续向下调用test方法本身，那么按照我们之前的逻辑推导，无限地插入栈帧那么一定会将虚拟机栈塞满，所以，当栈的深度已经不足以继续插入栈帧时，就会这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br><span class="line">	at com.test.Main.test(Main.java:12)</span><br><span class="line">	at com.test.Main.test(Main.java:12)</span><br><span class="line">	at com.test.Main.test(Main.java:12)</span><br><span class="line">	at com.test.Main.test(Main.java:12)</span><br><span class="line">	at com.test.Main.test(Main.java:12)</span><br><span class="line">	....以下省略很多行</span><br></pre></td></tr></table></figure>

<p>这也是我们常说的栈溢出，它和堆溢出比较类似，也是由于容纳不下才导致的，我们可以使用<code>-Xss</code>来设定栈容量。</p>
<h3 id="申请堆外内存"><a href="#申请堆外内存" class="headerlink" title="申请堆外内存"></a>申请堆外内存</h3><p>除了堆内存可以存放对象数据以外，我们也可以申请堆外内存（直接内存），也就是不受JVM管控的内存区域，这部分区域的内存需要我们自行去申请和释放，实际上本质就是JVM通过C/C++调用<code>malloc</code>函数申请的内存，当然得我们自己去释放了。不过虽然是直接内存，不会受到堆内存容量限制，但是依然会受到本机最大内存的限制，所以还是有可能抛出<code>OutOfMemoryError</code>异常。</p>
<p>这里我们**需要提到一个堆外内存操作类：<code>Unsafe</code>**，就像它的名字一样，虽然Java提供堆外内存的操作类，但是实际上它是不安全的，只有你完全了解底层原理并且能够合理控制堆外内存，才能安全地使用堆外内存。</p>
<p>注意这个类不让我们new，也没有直接获取方式（压根就没想让我们用）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Unsafe</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">registerNatives</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        registerNatives();</span><br><span class="line">        sun.reflect.Reflection.registerMethodsToFilter(Unsafe.class, <span class="string">&quot;getUnsafe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Unsafe</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">theUnsafe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Unsafe</span>();</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">        Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">        <span class="keyword">if</span> (!VM.isSystemDomainLoader(caller.getClassLoader()))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;Unsafe&quot;</span>);   <span class="comment">//不是JDK的类，不让用。</span></span><br><span class="line">        <span class="keyword">return</span> theUnsafe;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>所以我们这里就通过反射给他giao出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException &#123;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">unsafeField</span> <span class="operator">=</span> Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">    unsafeField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) unsafeField.get(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功拿到Unsafe类之后，我们就可以开始申请堆外内存了，比如我们现在想要申请一个int大小的内存空间，并在此空间中存放一个int类型的数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException &#123;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">unsafeField</span> <span class="operator">=</span> Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">    unsafeField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) unsafeField.get(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//申请4字节大小的内存空间，并得到对应位置的地址</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">address</span> <span class="operator">=</span> unsafe.allocateMemory(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">//在对应的地址上设定int的值</span></span><br><span class="line">    unsafe.putInt(address, <span class="number">6666666</span>);</span><br><span class="line">    <span class="comment">//获取对应地址上的Int型数值</span></span><br><span class="line">    System.out.println(unsafe.getInt(address));</span><br><span class="line">    <span class="comment">//释放申请到的内容</span></span><br><span class="line">    unsafe.freeMemory(address);</span><br><span class="line">    <span class="comment">//由于内存已经释放，这时数据就没了</span></span><br><span class="line">    System.out.println(unsafe.getInt(address));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以来看一下<code>allocateMemory</code>底层是如何调用的，这是一个native方法，我们来看C++源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UNSAFE_ENTRY</span>(jlong, <span class="built_in">Unsafe_AllocateMemory0</span>(JNIEnv *env, jobject unsafe, jlong size)) &#123;</span><br><span class="line">  <span class="type">size_t</span> sz = (<span class="type">size_t</span>)size;</span><br><span class="line">  sz = <span class="built_in">align_up</span>(sz, HeapWordSize);</span><br><span class="line">  <span class="type">void</span>* x = os::<span class="built_in">malloc</span>(sz, mtOther);   <span class="comment">//这里调用了os::malloc方法</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">addr_to_java</span>(x);</span><br><span class="line">&#125; UNSAFE_END</span><br></pre></td></tr></table></figure>

<p>接着来看：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">os::malloc</span><span class="params">(<span class="type">size_t</span> size, MEMFLAGS flags)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> os::<span class="built_in">malloc</span>(size, flags, CALLER_PC);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">os::malloc</span><span class="params">(<span class="type">size_t</span> size, MEMFLAGS memflags, <span class="type">const</span> NativeCallStack&amp; stack)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">  u_char* ptr;</span><br><span class="line">  ptr = (u_char*)::<span class="built_in">malloc</span>(alloc_size);   <span class="comment">//调用C++标准库函数 malloc(size)</span></span><br><span class="line">	....</span><br><span class="line">  <span class="comment">// we do not track guard memory</span></span><br><span class="line">  <span class="keyword">return</span> MemTracker::<span class="built_in">record_malloc</span>((address)ptr, size, memflags, stack, level);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，我们上面的Java代码转换为C代码，差不多就是这个意思：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> * a = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *a = <span class="number">6666666</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *a);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以说，直接内存实际上就是JVM申请的一块额外的内存空间，但是它并不在受管控的几种内存空间中，当然这些内存依然属于是JVM的，由于JVM提供的堆内存会进行垃圾回收等工作，效率不如直接申请和操作内存来得快，一些比较追求极致性能的框架会用到堆外内存来提升运行速度，如nio框架。</p>
<hr>
<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p>Java会自动管理和释放内存，它不像C/C++那样要求我们手动管理内存，JVM提供了一套全自动的内存管理机制，当一个Java对象不再用到时，JVM会自动将其进行回收并释放内存。</p>
<h3 id="对象存活判定算法"><a href="#对象存活判定算法" class="headerlink" title="对象存活判定算法"></a>对象存活判定算法</h3><p>首先我们来套讨论第一个问题，也就是：对象在什么情况下可以被判定为不再使用已经可以回收了？这里就需要提到以下几种垃圾回收算法了。</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24egy1gzm008b8j2j21ik0tagpd.jpg" alt="image-20220222084649786"></p>
<h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>我们知道，如果我们要经常操作一个对象，那么首先一定会创建一个引用变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//str就是一个引用类型的变量，它持有对后面字符串对象的引用，可以代表后面这个字符串对象本身</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;lbwnb&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>实际上，我们会发现，只要一个对象还有使用价值，我们就会通过它的引用变量来进行操作，那么可否这样判断一个对象是否还需要被使用：</p>
<ul>
<li>每个对象都包含一个 <strong>引用计数器</strong>，用于存放引用计数（其实就是存放被引用的次数）</li>
<li>每当有一个地方引用此对象时，引用计数<code>+1</code></li>
<li>当引用失效（ 比如离开了局部变量的作用域或是引用被设定为<code>null</code>）时，引用计数<code>-1</code></li>
<li>当引用计数为<code>0</code>时，表示此对象不可能再被使用，因为这时我们已经没有任何方法可以得到此对象的引用了</li>
</ul>
<p>但是这样存在一个问题，如果两个对象相互引用呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="type">Test</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        a.another = b;</span><br><span class="line">        b.another = a;</span><br><span class="line">        <span class="comment">//这里直接把a和b赋值为null，这样前面的两个对象我们不可能再得到了</span></span><br><span class="line">        a = b = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">        Test another;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照引用计数算法，那么当出现以上情况时，虽然我们无法在得到此对象的引用了，并且此对象我们也无需再使用，但是由于这两个对象直接存在相互引用的情况，那么引用计数器的值将会永远是<code>1</code>，但是实际上此对象已经没有任何用途了。所以引用计数法并不是最好的解决方案。</p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>目前比较主流的编程语言（包括Java），一般都会使用可达性分析算法来判断对象是否存活，它采用了类似于树结构的搜索机制。</p>
<p>首先每个对象的引用都有机会成为树的根节点（GC Roots），可以被选定作为根节点条件如下：</p>
<ul>
<li>位于虚拟机栈的栈帧中的本地变量表中所引用到的对象（其实就是我们方法中的局部变量）同样也包括本地方法栈中JNI引用的对象。</li>
<li>类的静态成员变量引用的对象。</li>
<li>方法区中，常量池里面引用的对象，比如我们之前提到的<code>String</code>类型对象。</li>
<li>被添加了锁的对象（比如synchronized关键字）</li>
<li>虚拟机内部需要用到的对象。</li>
</ul>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24egy1gzm76iz1mzj217s0ggwgc.jpg" alt="image-20220222125507229"></p>
<p>一旦已经存在的根节点不满足存在的条件时，那么根节点与对象之间的连接将被断开。此时虽然对象1仍存在对其他对象的引用，但是由于其没有任何根节点引用，所以此对象即可被判定为不再使用。比如某个方法中的局部变量引用，在方法执行完成返回之后对象1、2、3都会被回收，就解决了刚刚说的引用计数法中循环引用存在的问题。</p>
<p>所以，我们最后进行一下总结：如果某个对象无法到达任何GC Roots，则证明此对象是不可能再被使用的。</p>
<h4 id="最终判定"><a href="#最终判定" class="headerlink" title="最终判定"></a>最终判定</h4><p>虽然在经历了可达性分析算法之后基本可能判定哪些对象能够被回收，但是并不代表此对象一定会被回收，我们依然可以在最终判定阶段对其进行挽留。<code>Object</code>类的<code>finalize()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>此方法正是最终判定方法，如果子类重写了此方法，那么子类对象在被判定为可回收时，会进行二次确认，也就是执行<code>finalize()</code>方法，而在此方法中，<strong>当前对象是完全有可能重新建立GC Roots的</strong>。所以，如果在二次确认后对象不满足可回收的条件，那么此对象不会被回收，巧妙地逃过了垃圾回收的命运。比如下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Test a;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="comment">//这里直接把a赋值为null，这样前面的对象我们不可能再得到了</span></span><br><span class="line">        a  = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//手动申请执行垃圾回收操作（注意只是申请，并不一定会执行，但是一般情况下都会执行）</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">//等垃圾回收一下()</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//我们来看看a有没有被回收</span></span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>+<span class="string">&quot; 开始了它的救赎之路！&quot;</span>);</span><br><span class="line">            a = <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意<code>finalize()</code>方法并不是在主线程调用的，而是虚拟机自动建立的一个低优先级的<code>Finalizer</code>线程（正是因为优先级比较低，所以前面才需要等待1秒钟）进行处理，我们可以稍微修改一下看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(Thread.currentThread());</span><br><span class="line">        a = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread[Finalizer,8,system]</span><br><span class="line">com.test.Main$Test@232204a1</span><br></pre></td></tr></table></figure>

<p>同时，同一个对象的<code>finalize()</code>方法只会有一次调用机会，也就是说，如果我们连续两次这样操作，那么第二次，对象必定被回收：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    a = <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    <span class="comment">//这里直接把a赋值为null，这样前面的对象我们不可能再得到了</span></span><br><span class="line">    a  = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//手动申请执行垃圾回收操作（注意只是申请，并不一定会执行，但是一般情况下都会执行）</span></span><br><span class="line">    System.gc();</span><br><span class="line">    <span class="comment">//等垃圾回收一下</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    System.out.println(a);</span><br><span class="line">    <span class="comment">//这里直接把a赋值为null，这样前面的对象我们不可能再得到了</span></span><br><span class="line">    a  = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//手动申请执行垃圾回收操作（注意只是申请，并不一定会执行，但是一般情况下都会执行）</span></span><br><span class="line">    System.gc();</span><br><span class="line">    <span class="comment">//等垃圾回收一下</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，<code>finalize()</code>方法也并不是专门防止对象被回收的，我们可以使用它来释放一些程序使用中的资源等。</p>
<h4 id="一图总结GC-Roots"><a href="#一图总结GC-Roots" class="headerlink" title="一图总结GC Roots"></a>一图总结GC Roots</h4><p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24egy1gzm9o931z4j21n40letdm.jpg" alt="image-20220222141854678"></p>
<hr>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>前面我们介绍了对象存活判定算法，现在我们已经可以准确地知道堆中的哪些对象可以被回收了，那么，接下来就该考虑如何对对象进行回收了，垃圾收集器会不定期地检查堆中的对象，查看它们是否满足被回收的条件。</p>
<h4 id="分代收集机制"><a href="#分代收集机制" class="headerlink" title="分代收集机制"></a>分代收集机制</h4><p>Java虚拟机将堆内存划分为<strong>新生代</strong>、<strong>老年代</strong>和<strong>永久代</strong>（其中永久代是HotSpot虚拟机特有的概念，在JDK8之前方法区实际上就是采用的永久代作为实现，而在JDK8之后，方法区由元空间实现，并且使用的是本地内存，容量大小取决于物理机实际大小，之后会详细介绍）这里我们主要讨论的是<strong>新生代</strong>和<strong>老年代</strong>。</p>
<p>不同的分代内存回收机制也存在一些不同之处，在HotSpot虚拟机中，新生代被划分为三块，一块较大的Eden空间和两块较小的Survivor空间，默认比例为8：1：1，老年代的GC频率相对较低，永久代一般存放类信息等（其实就是方法区的实现）。</p>
<p>（1）首先，所有新创建的对象，在一开始都会进入到新生代的Eden区（如果是大对象会被直接丢进老年代），在进行新生代区域的垃圾回收时，首先会对所有新生代区域的对象进行扫描，并回收那些不再使用对象：</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24egy1gzmbyo48r0j21i20cqq4l.jpg" alt="image-20220222153104582"></p>
<p>（2）接着，在一次垃圾回收之后，Eden区域没有被回收的对象，会进入到Survivor区。在一开始From和To都是空的，而GC之后，所有Eden区域存活的对象都会直接被放入到From区，最后From和To会发生一次交换，也就是说目前存放我们对象的From区，变为To区，而To区变为From区：</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24egy1gzmbyn34yfj21gk0d4gn5.jpg" alt="image-20220222154032674"></p>
<p>接着就是下一次垃圾回收了，操作与上面是一样的，不过这时由于我们From区域中已经存在对象了，所以，在Eden区的存活对象复制到From区之后，所有To区域中的对象会进行年龄判定（每经历一轮GC年龄<code>+1</code>，如果对象的年龄大于<code>默认值为15</code>，那么会直接进入到老年代，否则移动到From区）</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24egy1gzmc6v1nzcj21h60d2q4l.jpg" alt="image-20220222154828416"></p>
<p>最后像上面一样交换To区和From区，之后不断重复以上步骤。</p>
<p>而垃圾收集也分为：</p>
<ul>
<li>Minor GC   -   次要垃圾回收，主要进行新生代区域的垃圾收集。<ul>
<li>触发条件：新生代的Eden区容量已满时。</li>
</ul>
</li>
<li>Major GC   -   主要垃圾回收，主要进行老年代的垃圾收集。</li>
<li>Full GC      -    完全垃圾回收，对整个Java堆内存和方法区进行垃圾回收。<ul>
<li>触发条件1：每次晋升到老年代的对象平均大小大于老年代剩余空间</li>
<li>触发条件2：Minor GC后存活的对象超过了老年代剩余空间</li>
<li>触发条件3：永久代内存不足（JDK8之前）</li>
<li>触发条件4：手动调用<code>System.gc()</code>方法</li>
</ul>
</li>
</ul>
<p>可以添加启动参数来查看JVM的GC日志：</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24egy1gzmd9jj8djj21m20gktav.jpg" alt="image-20220222162536616"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        o = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 2621K-&gt;528K(76288K)] 2621K-&gt;528K(251392K), 0.0006874 secs] [Times: user=0.01 sys=0.01, real=0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 528K-&gt;0K(76288K)] [ParOldGen: 0K-&gt;332K(175104K)] 528K-&gt;332K(251392K), [Metaspace: 3073K-&gt;3073K(1056768K)], 0.0022693 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 76288K, used 3277K [0x000000076ab00000, 0x0000000770000000, 0x00000007c0000000)</span><br><span class="line">  eden space 65536K, 5% used [0x000000076ab00000,0x000000076ae334d8,0x000000076eb00000)</span><br><span class="line">  from space 10752K, 0% used [0x000000076eb00000,0x000000076eb00000,0x000000076f580000)</span><br><span class="line">  to   space 10752K, 0% used [0x000000076f580000,0x000000076f580000,0x0000000770000000)</span><br><span class="line"> ParOldGen       total 175104K, used 332K [0x00000006c0000000, 0x00000006cab00000, 0x000000076ab00000)</span><br><span class="line">  object space 175104K, 0% used [0x00000006c0000000,0x00000006c00532d8,0x00000006cab00000)</span><br><span class="line"> Metaspace       used 3096K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 333K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>我们可以思考一下，有没有这样一种极端情况（正常情况下新生代的回收率是很高的，所以说不用太担心会经常出现这种问题），在一次GC后，新生代Eden区仍然存在大量的对象（因为GC之后存活对象会进入到一个Survivor区，但是很明显这时已经超出Survivor区的容量了，肯定是装不下的）那么现在该怎么办？</p>
<p>这时就需要用到空间分配担保机制了，<strong>可以把Survivor区无法容纳的对象直接送到老年代，让老年代进行分配担保</strong>（当然老年代也得装得下才行）在现实生活中，贷款会指定担保人，就是当借款人还不起钱的时候由担保人来还钱。</p>
<p>当新生代无法容纳更多的的对象时，可以把新生代中的对象移动到老年代中，这样新生代就腾出了空间来容纳更多的对象。</p>
<p>好，那既然新生代装不下就丢给老年代，那么要是老年代也装不下新生代的数据呢？这时，老年代肯定担保人是当不成了，那么这样的话，首先会判断一下之前的每次垃圾回收进入老年代的平均大小是否小于当前老年代的剩余空间，如果小于，那么说明也许可以放得下（不过也仅仅是也许，依然有可能放不下，因为判断的实际上只是平均值，万一这一次突然非常大呢），否则，会先来一次Full GC，进行一次大规模垃圾回收，来尝试腾出空间，再次判断老年代是否有空间存放，要是还是装不下，直接抛出OOM错误。</p>
<hr>
<h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>前面我们已经了解了整个堆内存实际上是以分代收集机制为主，但是依然没有讲到具体的收集过程，那么，具体的回收过程又是什么样的呢？首先我们来了解一下最古老的<code>标记-清除</code>算法。</p>
<p>首先标记出所有需要回收的对象，然后再依次回收掉被标记的对象，或是标记出所有不需要回收的对象，只回收未标记的对象。实际上这种算法是非常基础的，并且最易于理解的（这里对象我就以一个方框代替了，当然实际上存放是我们前说到的GC Roots形式）</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24egy1gzme6btluwj21e40c0760.jpg" alt="image-20220222165709034"></p>
<p>虽然此方法非常简单，但是缺点也是非常明显的 ，首先如果内存中存在大量的对象，那么可能就会存在大量的标记，并且大规模进行清除。并且一次标记清除之后，连续的内存空间可能会出现许许多多的空隙，碎片化会导致连续内存空间利用率降低。</p>
<h4 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h4><p>既然标记清除算法在面对大量对象时效率低，那么我们可以采用标记-复制算法。它将容量分为同样大小的两块区域，</p>
<p>标记复制算法，实际上就是将内存区域划分为大小相同的两块区域，每次只使用其中的一块区域，每次垃圾回收结束后，将所有存活的对象全部复制到另一块区域中，并一次性清空当前区域。虽然浪费了一些时间进行复制操作，但是这样能够很好地解决对象大面积回收后空间碎片化严重的问题。</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24ely1gzmlh5aveqj21ti0u079c.jpg" alt="image-20220222210942507"></p>
<p>这种算法就非常适用于新生代（因为新生代的回收效率极高，一般不会留下太多的对象）的垃圾回收，而我们之前所说的新生代Survivor区其实就是这个思路，包括8:1:1的比例也正是为了对标记复制算法进行优化而采取的。</p>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>虽然标记-复制算法能够很好地应对新生代高回收率的场景，但是放到老年代，它就显得很鸡肋了。我们知道，一般长期都回收不到的对象，才有机会进入到老年代，所以老年代一般都是些钉子户，可能一次GC后，仍然存留很多对象。而标记复制算法会在GC后完整复制整个区域内容，并且会折损50%的区域，显然这并不适用于老年代。</p>
<p>那么我们能否这样，在标记所有待回收对象之后，不急着去进行回收操作，而是将所有待回收的对象整齐排列在一段内存空间中，而需要回收的对象全部往后丢，这样，前半部分的所有对象都是无需进行回收的，而后半部分直接一次性清除即可。</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24ely1gzmm4g8voxj21vm08ywhj.jpg" alt="image-20220222213208681"></p>
<p>虽然这样能保证内存空间充分使用，并且也没有标记复制算法那么繁杂，但是缺点也是显而易见的，它的效率比前两者都低。甚至，由于需要修改对象在内存中的位置，此时程序必须要暂停才可以，在极端情况下，可能会导致整个程序发生停顿（被称为“Stop The World”）。</p>
<p>所以，我们可以将标记清除算法和标记整理算法混合使用，在内存空间还不是很凌乱的时候，采用标记清除算法其实是没有多大问题的，当内存空间凌乱到一定程度后，我们可以进行一次标记整理算法。</p>
<hr>
<h3 id="垃圾收集器实现"><a href="#垃圾收集器实现" class="headerlink" title="垃圾收集器实现"></a>垃圾收集器实现</h3><h4 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h4><p>这款垃圾收集器也是元老级别的收集器了，在JDK1.3.1之前，是虚拟机新生代区域收集器的唯一选择。这是一款<strong>单线程</strong>的垃圾收集器，也就是说，当开始进行垃圾回收时，需要暂停所有的线程，直到垃圾收集工作结束。它的<strong>新生代收集算法采用的是标记复制算法，老年代采用的是标记整理算法。</strong></p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24ely1gzn92k8ooej21ae0bc75m.jpg" alt="image-20220223104605648"></p>
<p>可以看到，当进入到垃圾回收阶段时，所有的用户线程必须等待GC线程完成工作，就相当于你打一把LOL 40分钟，中途每隔1分钟网络就卡5秒钟，可能这时你正在打团，结果你被物理控制直接在那里站了5秒钟，这确实让人难以接受。</p>
<p>虽然缺点很明显，但是优势也是显而易见的：</p>
<ol>
<li>设计简单而高效。</li>
<li>在用户的桌面应用场景中，内存一般不大，可以在较短时间内完成垃圾收集，只要不频繁发生，使用串行回收器是可以接受的。</li>
</ol>
<p>所以，在客户端模式（一般用于一些桌面级图形化界面应用程序）下的新生代中，默认垃圾收集器至今依然是Serial收集器。我们可以在<code>java -version</code>中查看默认的客户端模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openjdk version &quot;1.8.0_322&quot;</span><br><span class="line">OpenJDK Runtime Environment (Zulu 8.60.0.21-CA-macos-aarch64) (build 1.8.0_322-b06)</span><br><span class="line">OpenJDK 64-Bit Server VM (Zulu 8.60.0.21-CA-macos-aarch64) (build 25.322-b06, mixed mode)</span><br></pre></td></tr></table></figure>

<p>我们可以在jvm.cfg文件中切换JRE为Server VM或是Client VM，默认路径为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK安装目录/jre/lib/jvm.cfg</span><br></pre></td></tr></table></figure>

<p>比如我们需要将当前模式切换为客户端模式，那么我们可以这样编辑：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-client KNOWN</span><br><span class="line">-server IGNORE</span><br></pre></td></tr></table></figure>

<h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p>这款垃圾收集器相当于是Serial收集器的多线程版本，它能够支持多线程垃圾收集；除了多线程支持以外，其他内容基本与Serial收集器一致，并且目前某些JVM默认的服务端模式新生代收集器就是使用的ParNew收集器。</p>
<h4 id="Parallel-Scavenge-Parallel-Old收集器"><a href="#Parallel-Scavenge-Parallel-Old收集器" class="headerlink" title="Parallel Scavenge/Parallel Old收集器"></a>Parallel Scavenge/Parallel Old收集器</h4><p>Parallel Scavenge同样是一款面向新生代的垃圾收集器，同样采用标记复制算法实现，在JDK6时也推出了其老年代收集器Parallel Old，采用标记整理算法实现。</p>
<p>与ParNew收集器不同的是，它会自动衡量一个吞吐量，并根据吞吐量来决定每次垃圾回收的时间，这种自适应机制，能够很好地权衡当前机器的性能，根据性能选择最优方案。</p>
<p>目前JDK8采用的就是这种 Parallel Scavenge + Parallel Old 的垃圾回收方案。</p>
<h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>在JDK1.5，HotSpot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的并发（注意这里的并发和之前的并行是有区别的，并发可以理解为同时运行用户线程和GC线程，而并行可以理解为多条GC线程同时工作）收集器，它<strong>第一次实现了让垃圾收集线程与用户线程同时工作</strong>。</p>
<p>它主要采用<strong>标记清除</strong>算法：</p>
<img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24ely1gznamys2bdj21as0co404.jpg" alt="image-20220223114019381" style="zoom: 67%;" />

<p>它的垃圾回收分为4个阶段：</p>
<ul>
<li>初始标记（需要暂停用户线程）：这个阶段的主要任务仅仅只是标记出GC Roots能直接关联到的对象，速度比较快，不用担心会停顿太长时间。</li>
<li>并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</li>
<li>重新标记（需要暂停用户线程）：由于并发标记阶段可能某些用户线程会导致标记产生变得，因此这里需要再次暂停所有线程进行并行标记，这个时间会比初始标记时间长一丢丢。</li>
<li>并发清除：最后就可以直接将所有标记好的无用对象进行删除，因为这些对象程序中也用不到了，所以可以与用户线程并发运行。</li>
</ul>
<p>虽然它的优点非常之大，但是缺点也是显而易见的，我们之前说过，标记清除算法会产生大量的内存碎片，导致可用连续空间逐渐变少，长期这样下来，会有更高的概率触发Full GC，并且在与用户线程并发执行的情况下，也会占用一部分的系统资源，导致用户线程的运行速度一定程度上减慢。</p>
<p>不过，如果你希望的是最低的GC停顿时间，这款垃圾收集器无疑是最佳选择，不过自从G1收集器问世之后，CMS收集器不再推荐使用了。</p>
<h4 id="Garbage-First-G1-收集器"><a href="#Garbage-First-G1-收集器" class="headerlink" title="Garbage First (G1) 收集器"></a>Garbage First (G1) 收集器</h4><p>此垃圾收集器也是一款划时代的垃圾收集器，在JDK7的时候正式走上历史舞台，它是一款主要面向于服务端的垃圾收集器，并且在JDK9时，取代了JDK8默认的 Parallel Scavenge + Parallel Old 的回收方案。</p>
<p>我们知道，我们的垃圾回收分为<code>Minor GC</code>、<code>Major GC </code>和<code>Full GC</code>，它们分别对应的是新生代，老年代和整个堆内存的垃圾回收，而G1收集器巧妙地绕过了这些约定，它将整个Java堆划分成<code>2048</code>个大小相同的独立<code>Region</code>块，每个<code>Region块</code>的大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且都为2的N次幂。所有的<code>Region</code>大小相同，且在JVM的整个生命周期内不会发生改变。</p>
<p>那么分出这些<code>Region</code>有什么意义呢？每一个<code>Region</code>都可以根据需要，自由决定扮演哪个角色（Eden、Survivor和老年代），收集器会根据对应的角色采用不同的回收策略。此外，G1收集器还存在一个Humongous区域，它专门用于存放大对象（一般认为大小超过了Region容量一半的对象为大对象）这样，新生代、老年代在物理上，不再是一个连续的内存区域，而是到处分布的。</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24ely1gznc9jvdzdj21f40eiq4g.jpg" alt="image-20220223123636582"></p>
<p>它的回收过程与CMS大体类似：</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24ely1gznc8vqqqij21h00emwgt.jpg" alt="image-20220223123557871"></p>
<p>分为以下四个步骤：</p>
<ul>
<li>初始标记（暂停用户线程）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。</li>
<li>并发标记：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。</li>
<li>最终标记（暂停用户线程）：对用户线程做一个短暂的暂停，用于处理并发标记阶段漏标的那部分对象。</li>
<li>筛选回收：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多个收集器线程并行完成的。</li>
</ul>
<hr>
<h3 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h3><p>JDK8之前，Hotspot虚拟机的方法区实际上是永久代实现的。在JDK8之后，Hotspot虚拟机不再使用永久代，而是采用了全新的元空间。类的元信息被存储在元空间中。元空间没有使用堆内存，而是与堆不相连的本地内存区域。所以，理论上系统可以使用的内存有多大，元空间就有多大，所以不会出现永久代存在时的内存溢出问题。这项改造也是有必要的，永久代的调优是很困难的，虽然可以设置永久代的大小，但是很难确定一个合适的大小，因为其中的影响因素很多，比如类数量的多少、常量数量的多少等。</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24ely1gznd3pdzvyj21q20fcacr.jpg" alt="image-20220223130536357"></p>
<p>因此在JDK8时直接将本地内存作为元空间（<strong>Metaspace</strong>）的区域，物理内存有多大，元空间内存就可以有多大。</p>
<hr>
<h3 id="其他引用类型"><a href="#其他引用类型" class="headerlink" title="其他引用类型"></a>其他引用类型</h3><p>在Java中，如果变量是一个对象类型的，那么它实际上存放的是对象的引用，但是如果是一个基本类型，那么存放的就是基本类型的值。实际上我们平时代码中类似于<code>Object o = new Object()</code>这样的的引用类型，细分之后可以称为<code>强引用</code>。</p>
<p>我们通过前面的学习可以明确，如果方法中存在这样的<code>强引用</code>类型，现在需要回收强引用所指向的对象，那么要么此方法运行结束，要么引用连接断开，否则被引用的对象是无法被判定为可回收的，因为我们说不定后面还要使用它。</p>
<p>所以，当JVM内存空间不足时，JVM宁愿抛出OutOfMemoryError使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。</p>
<p>除了强引用之外，Java也为我们提供了三种额外的引用类型：</p>
<h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>软引用不像强引用那样不可回收，<u>当 JVM 认为内存不足时，会去试图回收软引用指向的对象，即JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。当然，如果内存充足，那么是不会轻易被回收的。</u></p>
<p>我们可以通过以下方式来创建一个软引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//强引用写法：Object obj = new Object();</span></span><br><span class="line">        <span class="comment">//软引用写法：</span></span><br><span class="line">        SoftReference&lt;Object&gt; reference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">        <span class="comment">//使用get方法就可以获取到软引用所指向的对象了</span></span><br><span class="line">        System.out.println(reference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到软引用还存在一个带队列的构造方法，软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<p>这里我们来进行一个测试，首先我们需要设定一下参数，来限制最大堆内存为10M，并且打印GC日志：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails -Xms10M -Xmx10M</span><br></pre></td></tr></table></figure>

<p>接着运行以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">        SoftReference&lt;Object&gt; reference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>(), queue);</span><br><span class="line">        System.out.println(reference);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) list.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;lbwnb&quot;</span>));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable t)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;发生了内存溢出！&quot;</span>+t.getMessage());</span><br><span class="line">            System.out.println(<span class="string">&quot;软引用对象：&quot;</span>+reference.get());</span><br><span class="line">            System.out.println(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ref.SoftReference@232204a1</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 3943K-&gt;501K(4608K)] 3943K-&gt;2362K(15872K), 0.0050615 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 3714K-&gt;496K(4608K)] 5574K-&gt;4829K(15872K), 0.0049642 secs] [Times: user=0.03 sys=0.00, real=0.01 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 3318K-&gt;512K(4608K)] 7652K-&gt;7711K(15872K), 0.0059440 secs] [Times: user=0.03 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) --[PSYoungGen: 4608K-&gt;4608K(4608K)] 11807K-&gt;15870K(15872K), 0.0078912 secs] [Times: user=0.05 sys=0.00, real=0.01 secs] </span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 4608K-&gt;0K(4608K)] [ParOldGen: 11262K-&gt;10104K(11264K)] 15870K-&gt;10104K(15872K), [Metaspace: 3207K-&gt;3207K(1056768K)], 0.0587856 secs] [Times: user=0.24 sys=0.00, real=0.06 secs] </span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 4096K-&gt;1535K(4608K)] [ParOldGen: 10104K-&gt;11242K(11264K)] 14200K-&gt;12777K(15872K), [Metaspace: 3207K-&gt;3207K(1056768K)], 0.0608198 secs] [Times: user=0.25 sys=0.01, real=0.06 secs] </span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 3965K-&gt;3896K(4608K)] [ParOldGen: 11242K-&gt;11242K(11264K)] 15207K-&gt;15138K(15872K), [Metaspace: 3207K-&gt;3207K(1056768K)], 0.0972088 secs] [Times: user=0.58 sys=0.00, real=0.10 secs] </span><br><span class="line">[Full GC (Allocation Failure) [PSYoungGen: 3896K-&gt;3896K(4608K)] [ParOldGen: 11242K-&gt;11225K(11264K)] 15138K-&gt;15121K(15872K), [Metaspace: 3207K-&gt;3207K(1056768K)], 0.1028222 secs] [Times: user=0.63 sys=0.01, real=0.10 secs] </span><br><span class="line">发生了内存溢出！Java heap space</span><br><span class="line">软引用对象：null</span><br><span class="line">java.lang.ref.SoftReference@232204a1</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 4608K, used 4048K [0x00000007bfb00000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">  eden space 4096K, 98% used [0x00000007bfb00000,0x00000007bfef40a8,0x00000007bff00000)</span><br><span class="line">  from space 512K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007bff80000)</span><br><span class="line">  to   space 512K, 0% used [0x00000007bff80000,0x00000007bff80000,0x00000007c0000000)</span><br><span class="line"> ParOldGen       total 11264K, used 11225K [0x00000007bf000000, 0x00000007bfb00000, 0x00000007bfb00000)</span><br><span class="line">  object space 11264K, 99% used [0x00000007bf000000,0x00000007bfaf64a8,0x00000007bfb00000)</span><br><span class="line"> Metaspace       used 3216K, capacity 4500K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 352K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>可以看到，当内存不足时，软引用所指向的对象被回收了，所以<code>get()</code>方法得到的结果为null，并且软引用对象本身被丢进了队列中。</p>
<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>弱引用比软引用的生命周期还要短，在进行垃圾回收时，<u>不管当前内存空间是否充足，都会回收它的内存。</u></p>
<p>我们可以像这样创建一个弱引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        WeakReference&lt;Object&gt; reference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">        System.out.println(reference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方法和软引用是差不多的，但是如果我们在这之前手动进行一次GC：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SoftReference&lt;Object&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">        WeakReference&lt;Object&gt; weakReference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//手动GC</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;软引用对象：&quot;</span>+softReference.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;弱引用对象：&quot;</span>+weakReference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，弱引用对象直接就被回收了，而软引用对象没有被回收。同样的，它也支持ReferenceQueue，和软引用用法一致，这里就不多做介绍了。</p>
<p><code>WeakHashMap</code>正是一种类似于弱引用的HashMap类，如果Map中的Key没有其他引用那么此Map会自动丢弃此键值对。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        WeakHashMap&lt;Integer, String&gt; weakHashMap = <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;&gt;();</span><br><span class="line">        weakHashMap.put(a, <span class="string">&quot;yyds&quot;</span>);</span><br><span class="line">        System.out.println(weakHashMap);</span><br><span class="line"></span><br><span class="line">        a = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        </span><br><span class="line">        System.out.println(weakHashMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，当变量a的引用断开后，这时只有WeakHashMap本身对此对象存在引用，所以在GC之后，这个键值对就自动被舍弃了。所以说这玩意，就挺适合拿去做缓存的。</p>
<h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>虚引用相当于没有引用，随时都有可能会被回收。</p>
<p>看看它的源码，非常简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhantomReference</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Reference</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns this reference object&#x27;s referent.  Because the referent of a</span></span><br><span class="line"><span class="comment">     * phantom reference is always inaccessible, this method always returns</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;null&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  &lt;code&gt;null&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new phantom reference that refers to the given object and</span></span><br><span class="line"><span class="comment">     * is registered with the given queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; It is possible to create a phantom reference with a &lt;tt&gt;null&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * queue, but such a reference is completely useless: Its &lt;tt&gt;get&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * method will always return null and, since it does not have a queue, it</span></span><br><span class="line"><span class="comment">     * will never be enqueued.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> referent the object the new phantom reference will refer to</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> q the queue with which the reference is to be registered,</span></span><br><span class="line"><span class="comment">     *          or &lt;tt&gt;null&lt;/tt&gt; if registration is not required</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PhantomReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="built_in">super</span> T&gt; q)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(referent, q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说我们无论调用多少次<code>get()</code>方法得到的永远都是<code>null</code>，因为虚引用本身就不算是个引用，相当于这个对象不存在任何引用，并且只能使用带队列的构造方法，以便对象被回收时接到通知。</p>
<p>最后，Java中4种引用的级别由高到低依次为：  <strong>强引用  &gt;  软引用  &gt;  弱引用  &gt;  虚引用</strong></p>
<hr>
<h1 id="三、类与类加载"><a href="#三、类与类加载" class="headerlink" title="三、类与类加载"></a>三、类与类加载</h1><h2 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h2><p>C语言编程过程分为如下几个阶段：编码、保存、编译、运行。实际上，最关键的一步是编译，因为只有经历了编译之后，我们所编写的代码才能够翻译为机器可以直接运行的二进制代码，并且在不同的操作系统下，我们的代码都需要进行一次编译之后才能运行。</p>
<blockquote>
<p>如果全世界所有的计算机指令集只有x86一种，操作系统只有Windows一种，那也许就不会有Java语言的出现。</p>
</blockquote>
<p>随着时代的发展，人们迫切希望能够在不同的操作系统、不同的计算机架构中运行同一套编译之后的代码。本地代码不应该是我们编程的唯一选择，所以，越来越多的语言选择了与操作系统和机器指令集无关的中立格式作为编译后的存储格式。</p>
<p>“一次编写，到处运行”，Java最引以为傲的口号，标志着平台不再是限制编程语言的阻碍。</p>
<p>实际上，Java正式利用了这样的解决方案，将源代码编译为平台无关的中间格式，并通过对应的Java虚拟机读取和运行这些中间格式的编译文件，这样，我们只需要考虑不同平台的虚拟机如何编写，而Java语言本身很轻松地实现了跨平台。</p>
<p>现在，越来越多的开发语言都支持将源代码编译为<code>.class</code>字节码文件格式，以便能够直接交给JVM运行，包括Kotlin（安卓开发官方指定语言）、Groovy、Scala等</p>
<h3 id="类文件信息"><a href="#类文件信息" class="headerlink" title="类文件信息"></a>类文件信息</h3><p>我们之前都是使用<code>javap</code>命令来对字节码文件进行反编译查看的，那么，它以二进制格式是怎么保存呢？我们可以使用WinHex软件（Mac平台可以使用<a target="_blank" rel="noopener" href="https://www.macwk.com/soft/010-editor">010 Editor</a>）来以十六进制查看字节码文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> i++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找到我们在IDEA中编译出来的class文件，将其拖动进去：</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24egy1gznjij4fgpj21800u011h.jpg" alt="image-20220223164725971"></p>
<p>可以看到整个文件中，全是一个字节一个字节分组的样子，从左上角开始，一行一行向下读取。可以看到在右侧中还出现了一些我们之前也许见过的字符串，比如”<init>“、”Object”等。</p>
<p>实际上Class文件采用了一种<strong>类似于C中结构体的伪结构来存储数据</strong>（当然我们直接看是看不出来的），但是如果像这样呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">Classfile /Users/nagocoler/Develop.localized/JavaHelloWorld/target/classes/com/test/Main.class</span><br><span class="line">  Last modified 2022-2-23; size 444 bytes</span><br><span class="line">  MD5 checksum 8af3e63f57bcb5e3d0eec4b0468de35b</span><br><span class="line">  Compiled from &quot;Main.java&quot;</span><br><span class="line">public class com.test.Main</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #3.#21         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Class              #22            // com/test/Main</span><br><span class="line">   #3 = Class              #23            // java/lang/Object</span><br><span class="line">   #4 = Utf8               &lt;init&gt;</span><br><span class="line">   #5 = Utf8               ()V</span><br><span class="line">   #6 = Utf8               Code</span><br><span class="line">   #7 = Utf8               LineNumberTable</span><br><span class="line">   #8 = Utf8               LocalVariableTable</span><br><span class="line">   #9 = Utf8               this</span><br><span class="line">  #10 = Utf8               Lcom/test/Main;</span><br><span class="line">  #11 = Utf8               main</span><br><span class="line">  #12 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #13 = Utf8               args</span><br><span class="line">  #14 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #15 = Utf8               i</span><br><span class="line">  #16 = Utf8               I</span><br><span class="line">  #17 = Utf8               a</span><br><span class="line">  #18 = Utf8               b</span><br><span class="line">  #19 = Utf8               SourceFile</span><br><span class="line">  #20 = Utf8               Main.java</span><br><span class="line">  #21 = NameAndType        #4:#5          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #22 = Utf8               com/test/Main</span><br><span class="line">  #23 = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  public com.test.Main();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 11: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/test/Main;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=4, args_size=1</span><br><span class="line">         0: bipush        10</span><br><span class="line">         2: istore_1</span><br><span class="line">         3: iload_1</span><br><span class="line">         4: iinc          1, 1</span><br><span class="line">         7: istore_2</span><br><span class="line">         8: iinc          1, 1</span><br><span class="line">        11: iload_1</span><br><span class="line">        12: istore_3</span><br><span class="line">        13: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 13: 0</span><br><span class="line">        line 14: 3</span><br><span class="line">        line 15: 8</span><br><span class="line">        line 16: 13</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      14     0  args   [Ljava/lang/String;</span><br><span class="line">            3      11     1     i   I</span><br><span class="line">            8       6     2     a   I</span><br><span class="line">           13       1     3     b   I</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;Main.java&quot;</span><br></pre></td></tr></table></figure>

<h3 id="类文件结构体"><a href="#类文件结构体" class="headerlink" title="类文件结构体"></a>类文件结构体</h3><p>而结构体中，有两种允许存在的数据类型，一个是无符号数，还有一个是表。</p>
<ul>
<li>无符号数一般是基本数据类型，用u1、u2、u4、u8来表示，表示1个字节~8个字节的无符号数。可以表示数字、索引引用、数量值或是以UTF-8编码格式的字符串。</li>
<li>表包含多个无符号数，并且以”_info”结尾。</li>
</ul>
<p>我们首先从最简的开始看起。</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24egy1gznjcb9bipj21ro0iutfs.jpg" alt="image-20220223164126100"></p>
<p>首先，我们可以看到，前4个字节（共32位）组成了魔数（其实就是表示这个文件是一个JVM可以运行的字节码文件，除了Java以外，其他某些文件中也采用了这种魔数机制来进行区分，<strong>这种方式比直接起个文件扩展名更安全</strong>）</p>
<h4 id="（1）魔数"><a href="#（1）魔数" class="headerlink" title="（1）魔数"></a>（1）魔数</h4><p><strong>字节码文件的魔数为：CAFEBABE</strong>（这名字能想出来也是挺难的了，毕竟4个bit位只能表示出A-F这几个字母）</p>
<h4 id="（2）版本号"><a href="#（2）版本号" class="headerlink" title="（2）版本号"></a>（2）版本号</h4><p>紧接着魔数的后面4个字节存储的是字节码文件的<strong>版本号</strong>，注意前两个是次要版本号（现在基本都不用了，都是直接Java8、Java9这样命名了），后面两个是主要版本号，这里我们主要看主版本号，比如上面的就是34，注意这是以16进制表示的，我们把它换算为10进制后，得到的结果为：<code>34  -&gt;  3*16 + 4 = 52</code>，<strong>其中<code>52</code>代表的是<code>JDK8</code>编译的字节码文件</strong>（51是JDK7、50是JDK6、53是JDK9，以此类推）</p>
<p>JVM会根据版本号决定是否能够运行，比如JDK6只能支持版本号为1.1到 6的版本，也就是说必须是Java6之前的环境编译出来的字节码文件，否则无法运行。又比如我们现在安装的是JDK8版本，它能够支持的版本号为1.1到 8，那么如果这时我们有一个通过Java7编译出来的字节码文件，依然是可以运行的，所以说Java版本是向下兼容的。</p>
<h4 id="（3）常量池"><a href="#（3）常量池" class="headerlink" title="（3）常量池"></a>（3）常量池</h4><p>这里面存放了类中所有的常量信息（注意这里的常量并不是指我们手动创建的final类型常量，而是程序运行一些需要用到的常量数据，比如字面量和符号引用等）由于常量的数量不是确定的，所以在最开始的位置会存放常量池中常量的数量（是从1开始计算的，不是0，比如这里是18，翻译为10进制就是24，所以实际上有23个常量）</p>
<p>接着再往下，就是常量池里面的数据了，每一项常量池里面的数据都是一个表，我们可以看到他们都是以_info结尾的：</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24egy1gznkh0jr31j21800u07dm.jpg" alt="image-20220223171746645"></p>
<p>我们来看看一个表中定义了哪些内容：</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24egy1gznkh14d4rj21b805wt9v.jpg" alt="image-20220223172031889"></p>
<p>首先上来就会有一个1字节的无符号数，它用于表示当前常量的类型（常量类型有很多个）这里只列举一部分的类型介绍：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">标志</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CONSTANT_Utf8_info</td>
<td align="center">1</td>
<td align="center">UTF-8编码格式的字符串</td>
</tr>
<tr>
<td align="center">CONSTANT_Integer_info</td>
<td align="center">3</td>
<td align="center">整形字面量（第一章我们演示的很大的数字，实际上就是以字面量存储在常量池中的）</td>
</tr>
<tr>
<td align="center">CONSTANT_Class_info</td>
<td align="center">7</td>
<td align="center">类或接口的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_String_info</td>
<td align="center">8</td>
<td align="center">字符串类型的字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Fieldref_info</td>
<td align="center">9</td>
<td align="center">字段的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_Methodref_info</td>
<td align="center">10</td>
<td align="center">方法的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_MethodType_info</td>
<td align="center">16</td>
<td align="center">方法类型</td>
</tr>
<tr>
<td align="center">CONSTANT_NameAndType_info</td>
<td align="center">12</td>
<td align="center">字段或方法的部分符号引用</td>
</tr>
</tbody></table>
<p>实际上这些东西，虽然我们不知道符号引用是什么东西，我们可以观察出来，这些东西或多或少都是存放类中一些名称、数据之类的东西。</p>
<p>比如我们来看第一个<code>CONSTANT_Methodref_info</code>表中存放了什么数据，这里我只列出它的结构表（详细的结构表可以查阅《深入理解Java虚拟机 第三版》中222页总表）：</p>
<table>
<thead>
<tr>
<th align="center">常量</th>
<th align="center">项目</th>
<th align="center">类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CONSTANT_Methodref_info</td>
<td align="center">tag</td>
<td align="center">u1</td>
<td align="center">值为10</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">index</td>
<td align="center">u2</td>
<td align="center">指向声明方法的类描述父CONSTANT_Class_info索引项</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">index</td>
<td align="center">u2</td>
<td align="center">指向名称及类型描述符CONSTANT_NameAndType_info索引项</td>
</tr>
</tbody></table>
<p>比如我们刚刚的例子中：</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24ely1gznnkpf7cqj21b40503zi.jpg" alt="image-20220223190659053"></p>
<p>可以看到，第一个索引项指向了第3号常量，我们来看看三号常量：</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24ely1gznnmsuh1pj219w03amxj.jpg" alt="image-20220223190957382"></p>
<table>
<thead>
<tr>
<th align="center">常量</th>
<th align="center">项目</th>
<th align="center">类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CONSTANT_Class_info</td>
<td align="center">tag</td>
<td align="center">u1</td>
<td align="center">值为7</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">index</td>
<td align="center">u2</td>
<td align="center">指向全限定名常量项的索引</td>
</tr>
</tbody></table>
<p>那么我们接着来看23号常量又写的啥：</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24ely1gznnqfknqaj21fo0j6te5.jpg" alt="image-20220223191325689"></p>
<p>可以看到指向的UTF-8字符串值为<code>java/lang/Object</code>这下搞明白了，首先这个方法是由Object类定义的，那么接着我们来看第二项u2 <code>name_and_type_index</code>，指向了21号常量，也就是字段或方法的部分符号引用：</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24ely1gzno0zakf9j21eg0qyqbl.jpg" alt="image-20220223191921550"></p>
<table>
<thead>
<tr>
<th align="center">常量</th>
<th align="center">项目</th>
<th align="center">类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CONSTANT_NameAndType_info</td>
<td align="center">tag</td>
<td align="center">u1</td>
<td align="center">值为12</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">index</td>
<td align="center">u2</td>
<td align="center">指向字段或方法名称常量项的索引</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">index</td>
<td align="center">u2</td>
<td align="center">指向字段或方法描述符常量项的索引</td>
</tr>
</tbody></table>
<p>其中第一个索引就是方法的名称，而第二个就是方法的描述符，描述符明确了方法的参数以及返回值类型，我们分别来看看4号和5号常量：</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24ely1gzno0z1yp1j21eg0qyqbl.jpg" alt="image-20220223192332068"></p>
<p>可以看到，方法名称为”<init>“，一般构造方法的名称都是<init>，普通方法名称是什么就是什么，方法描述符为”()V”，表示此方法没有任何参数，并且返回值类型为void，描述符对照表如下：</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24ely1gzno2stssaj216i08mjsr.jpg" alt="image-20220223192518999"></p>
<p>比如这里有一个方法<code>public int test(double a, char c)&#123; ... &#125;</code>，那么它的描述符就应该是：<code>(DC)I</code>，参数依次放入括号中，括号右边是返回值类型。再比如<code>public String test(Object obj)&#123; ... &#125;</code>，那么它的描述符就应该是：<code>(Ljava/lang/Object;)Ljava/lang/String</code>，注意如果参数是对象类型，那么必须在后面添加<code>;</code></p>
<p>对于数组类型，只需要在类型最前面加上<code>[</code>即可，有几个维度，就加几个，比如<code>public void test(int[][] arr)</code>，参数是一个二维int类型数组，那么它的描述符为：<code>([[I)V</code></p>
<p>所以，这里表示的，实际上就是此方法是一个无参构造方法，并且是属于Object类的。那么，为什么这里需要Object类构造方法的符号引用呢？还记得我们在JavaSE中说到的，每个类都是直接或间接继承自Object类，所有类的构造方法，必须先调用父类的构造方法，但是如果父类存在无参构造，默认可以不用显示调用<code>super</code>关键字（当然本质上是调用了的）。</p>
<p>所以说，当前类因为没有继承自任何其他类，那么就默认继承的Object类，所以，在当前类的默认构造方法中，调用了父类Object类的无参构造方法，因此这里需要符号引用的用途显而易见，就是因为需要调用Object类的无参构造方法。</p>
<p>我们可以在反编译结果中的方法中看到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public com.test.Main();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 11: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/test/Main;</span><br></pre></td></tr></table></figure>

<p>其中<code>invokespecial</code>（调用父类构造方法）指令的参数指向了1号常量，而1号常量正是代表的Object类的无参构造方法，虽然饶了这么大一圈，但是过程理清楚，还是很简单的。</p>
<p>虽然我们可以直接查看16进制的结果，但是还是不够方便，但是我们也不能每次都去使用<code>javap</code>命令，所以我们这里安装一个IDEA插件，来方便我们查看字节码中的信息，名称为<code>jclasslib Bytecode Viewer</code> ：</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24ely1gznojlqgl3j216y0dc0u0.jpg" alt="image-20220223194128297"></p>
<p>安装完成后，我们可以在我们的IDEA右侧看到它的板块，但是还没任何数据，那么比如现在我们想要查看Main类的字节码文件时，可以这样操作：</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24ely1gznomfiqu8j22ll0u0tfa.jpg" alt="image-20220223194410699"></p>
<p>首先在项目中选中我们的Main类，然后点击工具栏的视图，然后点击<code>Show Bytecode With Jclasslib</code>，这样右侧就会出现当前类的字节码解析信息了。注意如果修改了类的话，那么需要你点击运行或是构建，然后点击刷新按钮来进行更新。</p>
<h4 id="（4）访问标志"><a href="#（4）访问标志" class="headerlink" title="（4）访问标志"></a>（4）访问标志</h4><p>接着我们来看下一个内容，在常量池之后，紧接着就是<strong>访问标志</strong>，访问标志就是类的种类以及类上添加的一些关键字等内容：</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24ely1gznos6c7j9j21e60giq7s.jpg" alt="image-20220223194942810"></p>
<p>可以看到它只占了2个字节，那么它是如何表示访问标志呢?</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24ely1gznp9glonej216i0hcjui.jpg" alt="image-20220223200619811"></p>
<p>比如我们这里的Main类，它是一个普通的class类型，并且访问权限为public，那么它的访问标志值是这样计算的：</p>
<p><code>ACC_PUBLIC | ACC_SUPER = 0x0001 | 0x0020 = 0x0021</code>（这里进行的是按位或运算），可以看到和我们上面的结果是一致的。</p>
<p>再往下就是类索引、父类索引、接口索引：</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24ely1gznp3uofdej219803q0t7.jpg" alt="image-20220223200054866"></p>
<p>可以看到它们的值也是指向常量池中的值，其中2号常量正是存储的当前类信息，3号常量存储的是父类信息，这里就不再倒推回去了，由于没有接口，所以这里接口数量为0，如果不为0还会有一个索引表来引用接口。</p>
<h4 id="（5）字段和方法表集合"><a href="#（5）字段和方法表集合" class="headerlink" title="（5）字段和方法表集合"></a>（5）字段和方法表集合</h4><p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24ely1gznp8gd1nfj21ai04mdgp.jpg" alt="image-20220223200521912"></p>
<p>由于我们这里没有声明任何字段，所以我们先给Main类添加一个字段再重新加载一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> i++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24ely1gznpbh3k7rj21bi06o3zn.jpg" alt="image-20220223200733342"></p>
<p>现在字节码就新增了一个字段表，这个字段表实际上就是我们刚刚添加的成员字段<code>a</code>的数据。</p>
<p>可以看到一共有四个2字节的数据：</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24ely1gznpcxjzgfj216o06et9o.jpg" alt="image-20220223200939786"></p>
<p>首先是<code>access_flags</code>，这个与上面类标志的计算规则是一样的，表还是先列出来吧：</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24ely1gznpe7is4wj21620eswh4.jpg" alt="image-20220223201053780"></p>
<p>第二个数据<code>name_index</code>表示字段的名称常量，这里指向的是5号常量，那么我们来看看5号常量是不是字段名称：</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24ely1gznpgw09wjj21bc0tuk0x.jpg" alt="image-20220223201327180"></p>
<p>没问题，这里就是<code>a</code>,下一个是<code>descirptor_index</code>，存放的是描述符，不过这里因为不是方法而是变量，所以描述符直接写对应类型的标识字符即可，比如这里是<code>int</code>类型，那么就是<code>I</code>。</p>
<p>最后，<code>attrbutes_count</code>属性计数器，用于描述一些额外信息，这里我们暂时不做介绍。</p>
<p>接着就是我们的方法表了：</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24ely1gznppnxpcqj21ai04odgx.jpg" alt="image-20220223202153955"></p>
<p>可以看到方法表中一共有三个方法，其中第一个方法我们刚刚已经介绍过了，它的方法名称为<code>&lt;init&gt;</code>，表示它是一个构造方法，我们看到最后一个方法名称为<code>&lt;clinit&gt;</code>，这个是类在初始化时会调用的方法（是隐式的，自动生成的），它主要是用于静态变量初始化语句和静态块的执行，因为我们这里给静态成员变量a赋值为10，所以会在一开始为其赋值：</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24ely1gznpt5dhg3j224c0katcg.jpg" alt="image-20220223202515287"></p>
<p>而第二个方法，就是我们的<code>main</code>方法了，但是现在我们先不急着去看它的详细实现过程，我们来看看它的属性表。</p>
<p>属性表实际上类中、字段中、方法中都可以携带自己的属性表，属性表存放的正是我们的代码、本地变量等数据，比如main方法就存在4个本地变量，那么它的本地变量存放在哪里呢：</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24ely1gznpy0i9ehj21by0hywii.jpg" alt="image-20220223202955858"></p>
<p>可以看到，属性信息呈现套娃状态，在此方法中的属性包括了一个Code属性，此属性正是我们的Java代码编译之后变成字节码指令，然后存放的地方，而在此属性中，又嵌套了本地变量表和源码行号表。</p>
<p>可以看到code中存放的就是所有的字节码指令：</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24ely1gznq0wqe4xj215a0bi76l.jpg" alt="image-20220223203241262"></p>
<p>这里我们暂时不对字节码指令进行讲解（其实也用不着讲了，都认识的差不多了）。我们接着来看本地变量表，这里存放了我们方法中要用到的局部变量：</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24ely1gznq26f7rhj219w0ekq5v.jpg" alt="image-20220223203356129"></p>
<p>可以看到一共有四个本地变量，而第一个变量正是main方法的形参<code>String[] args</code>，并且表中存放了本地变量的长度、名称、描述符等内容。当然，除了我们刚刚认识的这几个属性之外，完整属性可以查阅《深入理解Java虚拟机 第三版》231页。</p>
<p>最后，类也有一些属性：</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24ely1gznq712n66j21dw0n20xw.jpg" alt="image-20220223203835282"></p>
<p>此属性记录的是源文件名称。</p>
<p>这样，我们对一个字节码文件的认识差不多就结束了，在了解了字节码文件的结构之后，是不是感觉豁然开朗？</p>
<hr>
<h3 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h3><p>虚拟机的指令是由一个字节长度的、代表某种特定操作含义的数字（操作码，类似于机器语言），操作后面也可以携带0个或多个参数一起执行。我们前面已经介绍过了，<strong>JVM实际上并不是面向寄存器架构的，而是面向操作数栈，所以大多数指令都是不带参数的</strong>。</p>
<p>由于之前已经讲解过大致运行流程，这里我们就以当前的Main类中的main方法作为教材进行讲解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> i++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，main方法中首先是定义了一个int类型的变量i，并赋值为10，然后变量a接收<code>i++</code>的值，变量b接收<code>++i</code>的值。</p>
<p>那么我们来看看编译成字节码之后，是什么样的：</p>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24ely1gznqsryzgfj225c0lgq6o.jpg" alt="image-20220223205928901"></p>
<ul>
<li>首先第一句，<code>bipush</code>，将10送至操作数栈顶。</li>
<li>接下来将操作数栈顶的数值存进1号本地变量，也就是变量i中。</li>
<li>接着将变量i中的值又丢向操作数栈顶</li>
<li>这里使用<code>iinc</code>指令，将1号本地变量的值增加1（结束之后i的值就是11了）</li>
<li>接着将操作数栈顶的值（操作数栈顶的值是10）存入2号本地变量（这下彻底知道i++到底干了啥才会先返回后自增了吧，从原理角度来说，实际上i是先自增了的，但由于这里取的是操作数栈中的值，所以说就得到了i之前的值）</li>
<li>接着往下，我们看到++i是先直接将i的值自增1</li>
<li>然后在将其值推向操作数栈顶</li>
</ul>
<p><img src="../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM/e6c9d24ely1gzns3syhe7j21x8090q5k.jpg" alt="image-20220223214441621"></p>
<p>而从结果来看，<code>i++</code>操作确实是先返回再自增的，而字节码指令层面来说，是先将i自增存入原变量，再将操作数栈的原值赋给a。<code>++i</code>是i自增再将值存入操作数栈。</p>
<hr>
<h3 id="ASM字节码编程"><a href="#ASM字节码编程" class="headerlink" title="ASM字节码编程"></a>ASM字节码编程</h3><p>既然字节码文件结构如此清晰，那么我们能否通过编程，来直接创建一个字节码文件呢？如果我们可以直接编写一个字节码文件，那么我们就可以省去编译的过程。ASM（某些JDK中内置）框架正是用于支持字节码编程的框架。</p>
<p>比如现在我们需要创建一个普通的Main类（暂时不写任何内容）</p>
<p>首先我们来看看如何通过编程创建一个Main类的字节码文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClassWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(ClassWriter.COMPUTE_MAXS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先需要获取<code>ClassWriter</code>对象，我们可以使用它来编辑类的字节码文件，在构造时需要传入参数：</p>
<ul>
<li>0     这种方式不会自动计算操作数栈和局部临时变量表大小，需要自己手动来指定</li>
<li>ClassWriter.COMPUTE_MAXS(1)     这种方式会自动计算上述操作数栈和局部临时变量表大小，但需要手动触发。</li>
<li>ClassWriter.COMPUTE_FRAMES(2)   这种方式不仅会计算上述操作数栈和局部临时变量表大小，而且会自动计算StackMapFrames</li>
</ul>
<p>这里我们使用<code>ClassWriter.COMPUTE_MAXS</code>即可。</p>
<p>接着我们首先需要指定类的一些基本信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClassWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(ClassWriter.COMPUTE_MAXS);</span><br><span class="line">        <span class="comment">//因为这里用到的常量比较多，所以说直接一次性静态导入：import static jdk.internal.org.objectweb.asm.Opcodes.*;</span></span><br><span class="line">        writer.visit(V1_8, ACC_PUBLIC,<span class="string">&quot;com/test/Main&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们将字节码文件的版本设定位Java8，然后修饰符设定为<code>ACC_PUBLIC</code>代表<code>public class Main</code>，类名称注意要携带包名，标签设置为<code>null</code>，父类设定为Object类，然后没有实现任何接口，所以说最后一个参数也是<code>null</code>。</p>
<p>接着，一个简单的类字节码文件就创建好了，我们可以尝试将其进行保存：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClassWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(ClassWriter.COMPUTE_MAXS);</span><br><span class="line">        writer.visit(V1_8, ACC_PUBLIC,<span class="string">&quot;com/test/Main&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//调用visitEnd表示结束编辑</span></span><br><span class="line">        writer.visitEnd();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>(<span class="type">FileOutputStream</span> <span class="variable">stream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;./Main.class&quot;</span>))&#123;</span><br><span class="line">            stream.write(writer.toByteArray());  <span class="comment">//直接通过ClassWriter将字节码文件转换为byte数组，并保存到根目录下</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在IDEA中反编译的结果为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道，正常的类在编译之后，如果没有手动添加构造方法，那么会自带一个无参构造，但是我们这个类中还没有，所以我们来手动添加一个无参构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过visitMethod方法可以添加一个新的方法</span></span><br><span class="line">writer.visitMethod(ACC_PUBLIC, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>可以看到反编译的结果中已经存在了我们的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Main</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样是不合法的，因为我们的构造方法还没有添加父类构造方法调用，所以说我们还需要在方法中添加父类构造方法调用指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public com.test.Main();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 11: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/test/Main;</span><br></pre></td></tr></table></figure>

<p>我们需要对方法进行详细编辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过MethodVisitor接收返回值，进行进一步操作</span></span><br><span class="line"><span class="type">MethodVisitor</span> <span class="variable">visitor</span> <span class="operator">=</span> writer.visitMethod(ACC_PUBLIC, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//开始编辑代码</span></span><br><span class="line">visitor.visitCode();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Label用于存储行号</span></span><br><span class="line"><span class="type">Label</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line"><span class="comment">//当前代码写到哪行了，l1得到的就是多少行</span></span><br><span class="line">visitor.visitLabel(l1);</span><br><span class="line"><span class="comment">//添加源码行数对应表（其实可以不用）</span></span><br><span class="line">visitor.visitLineNumber(<span class="number">11</span>, l1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意不同类型的指令需要用不同方法来调用，因为操作数不一致，具体的注释有写</span></span><br><span class="line">visitor.visitVarInsn(ALOAD, <span class="number">0</span>);</span><br><span class="line">visitor.visitMethodInsn(INVOKESPECIAL, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">visitor.visitInsn(RETURN);</span><br><span class="line"></span><br><span class="line"><span class="type">Label</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">visitor.visitLabel(l2);</span><br><span class="line"><span class="comment">//添加本地变量表，这里加的是this关键字，但是方法中没用到，其实可以不加</span></span><br><span class="line">visitor.visitLocalVariable(<span class="string">&quot;this&quot;</span>, <span class="string">&quot;Lcom/test/Main;&quot;</span>, <span class="literal">null</span>, l1, l2, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后设定最大栈深度和本地变量数</span></span><br><span class="line">visitor.visitMaxs(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//结束编辑</span></span><br><span class="line">visitor.visitEnd();</span><br></pre></td></tr></table></figure>

<p>我们可以对编写好的class文件进行反编译，看看是不是和IDEA编译之后的结果差不多：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  public com.test.Main();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #8                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/test/Main</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 11: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到和之前的基本一致了，到此为止我们构造方法就编写完成了，接着我们来写一下main方法，一会我们就可以通过main方法来运行Java程序了。比如我们要编写这样一个程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来很简单的一个程序对吧，但是我们如果手动去组装指令，会极其麻烦！首先main方法是一个静态方法，并且方法是public权限，然后还有一个参数<code>String[] args</code>，所以说我们这里要写的内容有点小多：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始安排main方法</span></span><br><span class="line"><span class="type">MethodVisitor</span> <span class="variable">v2</span> <span class="operator">=</span> writer.visitMethod(ACC_PUBLIC | ACC_STATIC, <span class="string">&quot;main&quot;</span>, <span class="string">&quot;([Ljava/lang/String;)V&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">v2.visitCode();</span><br><span class="line"><span class="comment">//记录起始行信息</span></span><br><span class="line"><span class="type">Label</span> <span class="variable">l3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">v2.visitLabel(l3);</span><br><span class="line">v2.visitLineNumber(<span class="number">13</span>, l3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先是int a = 10的操作，执行指令依次为：</span></span><br><span class="line"><span class="comment">// bipush 10     将10推向操作数栈顶</span></span><br><span class="line"><span class="comment">// istore_1      将操作数栈顶元素保存到1号本地变量a中</span></span><br><span class="line">v2.visitIntInsn(BIPUSH, <span class="number">10</span>);</span><br><span class="line">v2.visitVarInsn(ISTORE, <span class="number">1</span>);</span><br><span class="line"><span class="type">Label</span> <span class="variable">l4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">v2.visitLabel(l4);</span><br><span class="line"><span class="comment">//记录一下行信息</span></span><br><span class="line">v2.visitLineNumber(<span class="number">14</span>, l4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里是获取System类中的out静态变量（PrintStream接口），用于打印</span></span><br><span class="line">v2.visitFieldInsn(GETSTATIC, <span class="string">&quot;java/lang/System&quot;</span>, <span class="string">&quot;out&quot;</span>, <span class="string">&quot;Ljava/io/PrintStream;&quot;</span>);</span><br><span class="line"><span class="comment">//把a的值取出来</span></span><br><span class="line">v2.visitVarInsn(ILOAD, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//调用接口中的抽象方法println</span></span><br><span class="line">v2.visitMethodInsn(INVOKEVIRTUAL, <span class="string">&quot;java/io/PrintStream&quot;</span>, <span class="string">&quot;println&quot;</span>, <span class="string">&quot;(I)V&quot;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//再次记录行信息</span></span><br><span class="line"><span class="type">Label</span> <span class="variable">l6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">v2.visitLabel(l6);</span><br><span class="line">v2.visitLineNumber(<span class="number">15</span>, l6);</span><br><span class="line"></span><br><span class="line">v2.visitInsn(RETURN);</span><br><span class="line"><span class="type">Label</span> <span class="variable">l7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">v2.visitLabel(l7);</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后是本地变量表中的各个变量</span></span><br><span class="line">v2.visitLocalVariable(<span class="string">&quot;args&quot;</span>, <span class="string">&quot;[Ljava/lang/String;&quot;</span>, <span class="literal">null</span>, l3, l7, <span class="number">0</span>);</span><br><span class="line">v2.visitLocalVariable(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="literal">null</span>, l4, l7, <span class="number">1</span>);</span><br><span class="line">v2.visitMaxs(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//终于OK了</span></span><br><span class="line">v2.visitEnd();</span><br></pre></td></tr></table></figure>

<p>可以看到，虽然很简单的一个程序，但是如果我们手动去编写字节码，实际上是非常麻烦的，但是要实现动态代理之类的操作（可以很方便地修改字节码创建子类），是不是感觉又Get到了新操作（其实Spring实现动态代理的CGLib框架底层正是调用了ASM框架来实现的），所以说了解一下还是可以的，不过我们自己肯定是没多少玩这个的机会了。</p>
<hr>
<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">lcq</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/post/89aaa22d.html">http://example.com/post/89aaa22d.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java-jvm/">java jvm</a></div><div class="post_share"><div class="social-share" data-image="https://iw233.cn/api.php?sort=pc" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> Donate</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg"/></a><div class="post-qr-code-desc"></div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg"/></a><div class="post-qr-code-desc"></div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/282c1c27.html"><img class="prev-cover" src="https://iw233.cn/api.php?sort=pc" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">快速算法及技巧</div></div></a></div><div class="next-post pull-right"><a href="/post/16518a5d.html"><img class="next-cover" src="https://iw233.cn/api.php?sort=pc" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">单调栈</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">lcq</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">28</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/lcqlcqq" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM"><span class="toc-number">1.</span> <span class="toc-text">JVM</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81JVM%E6%A6%82%E8%BF%B0"><span class="toc-number"></span> <span class="toc-text">一、JVM概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0"><span class="toc-number">0.1.</span> <span class="toc-text">技术概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E7%BC%96%E8%AF%91"><span class="toc-number">0.2.</span> <span class="toc-text">反编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><span class="toc-number">0.3.</span> <span class="toc-text">虚拟机的发展历程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%91%E5%B1%95%E7%9A%84%E6%9C%AA%E6%9D%A5"><span class="toc-number">0.4.</span> <span class="toc-text">虚拟机发展的未来</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%8E%A2%E7%A9%B6"><span class="toc-number">0.5.</span> <span class="toc-text">JVM启动流程探究</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%9B%BE%E6%80%BB%E7%BB%93JVM%E5%90%AF%E5%8A%A8%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">0.6.</span> <span class="toc-text">一图总结JVM启动执行过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JNI-%E8%B0%83%E7%94%A8%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95"><span class="toc-number">0.7.</span> <span class="toc-text">JNI 调用本地方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number"></span> <span class="toc-text">二、JVM内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86"><span class="toc-number">1.</span> <span class="toc-text">内存区域划分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E8%87%B4%E5%88%92%E5%88%86"><span class="toc-number">1.1.</span> <span class="toc-text">大致划分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">程序计数器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">1.1.2.</span> <span class="toc-text">虚拟机栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-number">1.1.3.</span> <span class="toc-text">本地方法栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">1.1.4.</span> <span class="toc-text">堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">1.1.5.</span> <span class="toc-text">方法区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E5%90%84%E4%B8%AA%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-number">1.1.6.</span> <span class="toc-text">总结各个内存区域的用途</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%86%E5%86%85%E5%AD%98%E5%92%8C%E7%88%86%E6%A0%88"><span class="toc-number">1.2.</span> <span class="toc-text">爆内存和爆栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B3%E8%AF%B7%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98"><span class="toc-number">1.3.</span> <span class="toc-text">申请堆外内存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%AD%98%E6%B4%BB%E5%88%A4%E5%AE%9A%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">对象存活判定算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">2.1.1.</span> <span class="toc-text">引用计数法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.2.</span> <span class="toc-text">可达性分析算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E5%88%A4%E5%AE%9A"><span class="toc-number">2.1.3.</span> <span class="toc-text">最终判定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E5%9B%BE%E6%80%BB%E7%BB%93GC-Roots"><span class="toc-number">2.1.4.</span> <span class="toc-text">一图总结GC Roots</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6"><span class="toc-number">2.2.1.</span> <span class="toc-text">分代收集机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D"><span class="toc-number">2.2.2.</span> <span class="toc-text">空间分配担保</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.3.</span> <span class="toc-text">标记-清除算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.4.</span> <span class="toc-text">标记-复制算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.5.</span> <span class="toc-text">标记-整理算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.</span> <span class="toc-text">垃圾收集器实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Serial"><span class="toc-number">2.3.1.</span> <span class="toc-text">Serial</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ParNew%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.3.2.</span> <span class="toc-text">ParNew收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Parallel-Scavenge-Parallel-Old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.3.3.</span> <span class="toc-text">Parallel Scavenge&#x2F;Parallel Old收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CMS%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.3.4.</span> <span class="toc-text">CMS收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Garbage-First-G1-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.3.5.</span> <span class="toc-text">Garbage First (G1) 收集器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%A9%BA%E9%97%B4"><span class="toc-number">2.4.</span> <span class="toc-text">元空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.5.</span> <span class="toc-text">其他引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8"><span class="toc-number">2.5.1.</span> <span class="toc-text">软引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="toc-number">2.5.2.</span> <span class="toc-text">弱引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8"><span class="toc-number">2.5.3.</span> <span class="toc-text">虚引用</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%B1%BB%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-number"></span> <span class="toc-text">三、类与类加载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">类文件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF"><span class="toc-number">1.1.</span> <span class="toc-text">类文件信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.2.</span> <span class="toc-text">类文件结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E9%AD%94%E6%95%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">（1）魔数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="toc-number">1.2.2.</span> <span class="toc-text">（2）版本号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">1.2.3.</span> <span class="toc-text">（3）常量池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97"><span class="toc-number">1.2.4.</span> <span class="toc-text">（4）访问标志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E5%AD%97%E6%AE%B5%E5%92%8C%E6%96%B9%E6%B3%95%E8%A1%A8%E9%9B%86%E5%90%88"><span class="toc-number">1.2.5.</span> <span class="toc-text">（5）字段和方法表集合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4"><span class="toc-number">1.3.</span> <span class="toc-text">字节码指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ASM%E5%AD%97%E8%8A%82%E7%A0%81%E7%BC%96%E7%A8%8B"><span class="toc-number">1.4.</span> <span class="toc-text">ASM字节码编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">类加载机制</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/aa2d234c.html" title="redis集群部署">redis集群部署</a><time datetime="2022-09-12T15:17:23.000Z" title="Created 2022-09-12 23:17:23">2022-09-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/bffce109.html" title="nacos集群配置调试踩坑">nacos集群配置调试踩坑</a><time datetime="2022-09-12T15:15:47.000Z" title="Created 2022-09-12 23:15:47">2022-09-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/91b7113d.html" title="nacos集群及nginx配置">nacos集群及nginx配置</a><time datetime="2022-09-12T15:12:46.000Z" title="Created 2022-09-12 23:12:46">2022-09-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/c6c26c67.html" title="ES笔记">ES笔记</a><time datetime="2022-08-30T16:34:02.000Z" title="Created 2022-08-31 00:34:02">2022-08-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/620e6e72.html" title="SpringBoot订阅binlog实现数据异步更新">SpringBoot订阅binlog实现数据异步更新</a><time datetime="2022-08-30T16:32:45.000Z" title="Created 2022-08-31 00:32:45">2022-08-31</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By lcq</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>