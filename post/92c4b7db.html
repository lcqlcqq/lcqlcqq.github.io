<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>SpringCloud笔记（3） | Syerenc</title><meta name="keywords" content="SpringCloud"><meta name="author" content="lcq"><meta name="copyright" content="lcq"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="微服务中间件消息队列我们之前如果需要进行远程调用，那么一般可以通过发送HTTP请求来完成，而现在，我们可以使用第二种方式实现服务调用，就是消息队列，它能够将发送方发送的信息放入队列中，当新的消息入队时，会通知接收方进行处理，一般消息发送方称为生产者，接收方称为消费者。 这样我们所有的请求，都可以直接丢到消息队列中，再由消费者取出，不再是直接连接消费者的形式了，而是加了一个中间商，这也是一种很好的解">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringCloud笔记（3）">
<meta property="og:url" content="http://example.com/post/92c4b7db.html">
<meta property="og:site_name" content="Syerenc">
<meta property="og:description" content="微服务中间件消息队列我们之前如果需要进行远程调用，那么一般可以通过发送HTTP请求来完成，而现在，我们可以使用第二种方式实现服务调用，就是消息队列，它能够将发送方发送的信息放入队列中，当新的消息入队时，会通知接收方进行处理，一般消息发送方称为生产者，接收方称为消费者。 这样我们所有的请求，都可以直接丢到消息队列中，再由消费者取出，不再是直接连接消费者的形式了，而是加了一个中间商，这也是一种很好的解">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://iw233.cn/api.php?sort=pc">
<meta property="article:published_time" content="2022-10-16T08:24:03.000Z">
<meta property="article:modified_time" content="2022-11-12T16:09:42.237Z">
<meta property="article:author" content="lcq">
<meta property="article:tag" content="SpringCloud">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://iw233.cn/api.php?sort=pc"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/post/92c4b7db"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'SpringCloud笔记（3）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-13 00:09:42'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/source/css/jianbian.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"> <script src="/live2d-widget/autoload.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">30</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">15</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://iw233.cn/api.php?sort=pc')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Syerenc</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">SpringCloud笔记（3）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-10-16T08:24:03.000Z" title="Created 2022-10-16 16:24:03">2022-10-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-11-12T16:09:42.237Z" title="Updated 2022-11-13 00:09:42">2022-11-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/SpringCloud/">SpringCloud</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">7.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>24min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="SpringCloud笔记（3）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="微服务中间件"><a href="#微服务中间件" class="headerlink" title="微服务中间件"></a>微服务中间件</h1><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>我们之前如果需要进行远程调用，那么一般可以通过发送HTTP请求来完成，而现在，我们可以使用第二种方式实现服务调用，就是消息队列，它能够将发送方发送的信息放入队列中，当新的消息入队时，会通知接收方进行处理，一般消息发送方称为生产者，接收方称为消费者。</p>
<p>这样我们所有的请求，都可以直接丢到消息队列中，再由消费者取出，不再是直接连接消费者的形式了，而是加了一个中间商，这也是一种很好的<strong>解耦</strong>方案，并且在高并发的情况下，由于消费者能力有限，消息队列也能起到一个<strong>削峰填谷</strong>的作用，堆积一部分的请求，再由消费者来慢慢处理，而不会像直接调用那样请求蜂拥而至。</p>
<p>那么，消息队列具体实现有哪些呢：</p>
<ul>
<li>RabbitMQ  -  性能很强，吞吐量很高，支持多种协议，集群化，消息的可靠执行特性等优势，很适合企业的开发。</li>
<li>Kafka - 提供了超高的吞吐量，ms级别的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。</li>
<li>RocketMQ  -  阿里巴巴推出的消息队列，经历过双十一的考验，单机吞吐量高，消息的高可靠性，扩展性强，支持事务等，但是功能不够完整，语言支持性较差。</li>
</ul>
<h3 id="RabbitMQ-消息队列"><a href="#RabbitMQ-消息队列" class="headerlink" title="RabbitMQ 消息队列"></a>RabbitMQ 消息队列</h3><p><strong>官方网站：</strong><a target="_blank" rel="noopener" href="https://www.rabbitmq.com/">https://www.rabbitmq.com</a></p>
<blockquote>
<p>RabbitMQ拥有数万计的用户，是最受欢迎的开源消息队列之一，从<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=1qcTu2QUtrU">T-Mobile</a>到<a target="_blank" rel="noopener" href="https://medium.com/@runtastic/messagebus-handling-dead-letters-in-rabbitmq-using-a-dead-letter-exchange-f070699b952b">Runtastic</a>，RabbitMQ在全球范围内用于小型初创企业和大型企业。</p>
<p>RabbitMQ轻量级，易于在本地和云端部署，它支持多种消息协议。RabbitMQ可以部署在分布式和联合配置中，以满足大规模、高可用性要求。</p>
<p>RabbitMQ在许多操作系统和云环境中运行，并为<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/devtools.html">大多数流行语言</a>提供了<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/devtools.html">广泛的开发者工具</a>。</p>
</blockquote>
<p>RabbitMQ 是采用 Erlang 语言实现 <strong>AMQP</strong>(Advanced Message Queuing Protocol，高级消息队列协议）的消息中间件，它最初起源于金融系统，用于在分布式系统中存储转发消息。</p>
<h3 id="一、安装erlang"><a href="#一、安装erlang" class="headerlink" title="一、安装erlang"></a>一、安装erlang</h3><p>1，下载地址：<a target="_blank" rel="noopener" href="http://www.erlang.org/downloads">http://www.erlang.org/downloads</a><br>2，配置环境变量：（系统变量）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">变量名：ERLANG_HOME</span><br><span class="line">地址：到<span class="built_in">bin</span>的上一级目录</span><br></pre></td></tr></table></figure>

<p>3，双击系统变量path<br>点击“新建”，将%ERLANG_HOME%\bin加入到path中。<br>4，测试：<br>cmd——erl</p>
<h3 id="二、安装RabbitMQ"><a href="#二、安装RabbitMQ" class="headerlink" title="二、安装RabbitMQ"></a>二、安装RabbitMQ</h3><p>1，下载地址：<a target="_blank" rel="noopener" href="http://www.rabbitmq.com/download.html">http://www.rabbitmq.com/download.html</a><br>2，安装RabbitMQ-Plugins（sbin目录下安装）—–可视化插件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令：rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br></pre></td></tr></table></figure>

<h3 id="三、测试登录"><a href="#三、测试登录" class="headerlink" title="三、测试登录"></a>三、测试登录</h3><p>1，cmd到sbin目录：输入 rabbitmqctl status<br>2，启动服务————双击rabbitmq-server.bat，访问：<a target="_blank" rel="noopener" href="http://localhost:15672/">http://localhost:15672</a><br>用户名/密码：guest</p>
<p>rabbitmqctl status查看状态，管理面板是端口15672，使用的是HTTP协议：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Listeners</span><br><span class="line"></span><br><span class="line">Interface: [::], port: 25672, protocol: clustering, purpose: inter-node and CLI tool communication</span><br><span class="line">Interface: [::], port: 5672, protocol: amqp, purpose: AMQP 0-9-1 and AMQP 1.0</span><br><span class="line">Interface: [::], port: 15672, protocol: http, purpose: HTTP API</span><br></pre></td></tr></table></figure>

<p>进入了之后会显示当前的消息队列情况，包括版本号、Erlang版本等，这里需要介绍一下RabbitMQ的设计架构。</p>
<h2 id="RabbitMQ-架构"><a href="#RabbitMQ-架构" class="headerlink" title="RabbitMQ 架构"></a>RabbitMQ 架构</h2><ul>
<li><strong>生产者（Publisher）和消费者（Consumer）：</strong>生产消息的一方（邮件投递者）以及消费消息的一方（邮件收件人）。</li>
<li><strong>Channel：</strong>我们的客户端连接都会使用一个Channel，再通过Channel去访问到RabbitMQ服务器，注意通信协议不是http，而是AMQP协议。</li>
<li><strong>Exchange：</strong>类似于交换机一样的存在，会根据我们的请求，转发给相应的消息队列，每个队列都可以绑定到Exchange上，这样Exchange就可以将数据转发给队列了，可以存在很多个，不同的Exchange类型可以用于实现不同消息的模式。</li>
<li><strong>Queue：</strong>消息队列本体，生产者所有的消息都存放在消息队列中，等待消费者取出。</li>
<li><strong>Virtual Host：</strong>有点类似于环境隔离，不同环境都可以单独配置一个Virtual Host，每个Virtual Host可以包含很多个Exchange和Queue，每个Virtual Host相互之间不影响。</li>
</ul>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/e6c9d24ely1h1bcul1hzzj21r40iogq3.jpg" alt="image-20220416103043845"></p>
<h3 id="Exchange-交换机-详解："><a href="#Exchange-交换机-详解：" class="headerlink" title="Exchange(交换机)详解："></a>Exchange(交换机)详解：</h3><p>在 RabbitMQ 中，消息并不是直接被投递到 <strong>Queue(消息队列)</strong> 中的，中间还必须经过 <strong>Exchange(交换器)</strong> 这一层，它会把我们的消息分配到对应的 <strong>Queue(消息队列)</strong> 中。<strong>Exchange(交换器)</strong> 用来接收生产者发送的消息并将这些消息路由给服务器中的队列中，如果路由不到，或许会返回给 <strong>Producer(生产者)</strong> ，或许会被直接丢弃掉 。</p>
<h4 id="交换机类型"><a href="#交换机类型" class="headerlink" title="交换机类型"></a>交换机类型</h4><p>Exchange(交换器) 有4种类型，不同的类型对应着不同的路由策略：<strong>direct(默认)<strong>，</strong>fanout</strong>, <strong>topic</strong>, 和 <strong>headers</strong>，</p>
<blockquote>
<p>（1）direct（指定队列模式）：将队列绑定到交换机，消息的 routeKey 需要与队列绑定的 routeKey 相同。<br>（2）fanout （广播模式）：不处理 routeKey，直接把消息转发到与其绑定的所有队列中。<br>（3）topic（主题模式）：根据一定的规则，根据 routeKey 把消息转发到符合规则的队列中，其中 # 用于匹配符合一个或者多个词（范围更广）， * 用于匹配一个词。<br>（4）headers （头模式）：根据消息的 headers 转发消息而不是根据 routeKey 来转发消息, 其中 header 是一个 Map，也就意味着不仅可以匹配字符串类型，也可以匹配其他类型数据。 规则可以分为所有键值对匹配或者单一键值对匹配。</p>
</blockquote>
<p>生产者将消息发给交换器的时候，一般会指定一个 **RoutingKey(路由键)**，用来指定这个消息的路由规则，而这个 <strong>RoutingKey 需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效</strong>。</p>
<p>RabbitMQ 中通过 <strong>Binding(绑定)</strong> 将 <strong>Exchange(交换器)</strong> 与 <strong>Queue(消息队列)</strong> 关联起来，在绑定的时候一般会指定一个 <strong>BindingKey(绑定建)</strong> ,这样 RabbitMQ 就知道如何正确将消息路由到队列了,如下图所示。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。Exchange 和 Queue 的绑定可以是多对多的关系。</p>
<p>生产者将消息发送给交换器时，需要一个RoutingKey，当 BindingKey 和 RoutingKey 相匹配时，消息会被路由到对应的队列中。在绑定多个队列到同一个交换器的时候，这些绑定允许使用相同的 BindingKey。BindingKey 并不是在所有的情况下都生效，它依赖于交换器类型，比如fanout类型的交换器就会无视，而是将消息路由到所有绑定到该交换器的队列中。</p>
<h2 id="RabbitMQ-的六种消息模式"><a href="#RabbitMQ-的六种消息模式" class="headerlink" title="RabbitMQ 的六种消息模式"></a>RabbitMQ 的六种消息模式</h2><blockquote>
<p>（1）Simple Work Queue （简单工作队列）：也就是常说的点对点模式，一条消息由一个或多个消费者进行消费。（当有多个消费者时，默认使用<strong>轮询</strong>机制把消息分配给消费者）。<br>（2）Work Queues （工作队列）：也叫公平队列，<strong>能者多劳</strong>的消息队列模型。队列必须接收到来自消费者的手动ack才可以继续往消费者发送消息。<br>（3）Publish/Subscribe （发布订阅模式）：一条消息被多个消费者消费。<br>（4）Routing（路由模式）：有选择的接收消息。<br>（5）Topics （主题模式）：通过一定的规则来选择性的接收消息<br>（6）RPC 模式：发布者发布消息，并且通过 RPC 方式等待结果。目前这个应该场景少，而且代码也较为复杂。</p>
</blockquote>
<p>我们就从最简的的模型开始讲起：</p>
<h3 id="1、简单工作队列模式：（direct类型交换机）"><a href="#1、简单工作队列模式：（direct类型交换机）" class="headerlink" title="1、简单工作队列模式：（direct类型交换机）"></a>1、简单工作队列模式：（direct类型交换机）</h3><p>（一个生产者 -&gt; 消息队列 -&gt; 一个消费者）</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/e6c9d24ely1h1cin640c8j21fg06ajrh.jpg" alt="image-20220417103647609"></p>
<p>生产者只需要将数据丢进消息队列，而消费者只需要将数据从消息队列中取出，这样就实现了生产者和消费者的消息交互。</p>
<p>我们现在来演示一下，首先进入到我们的管理页面，进入Admin栏目，这里创建一个新的实验环境，只需要新建一个Virtual Host即可：</p>
<blockquote>
<p>name:/test<br>description:测试环境</p>
</blockquote>
<p>添加新的虚拟主机之后，我们可以看到，当前admin用户的主机访问权限中新增了我们刚刚添加的环境。（需要先创建一个admin用户）</p>
<p>现在我们来看看交换机，进入Exchange栏目，看到自动新增了以下阴影部分：</p>
<img src="../images/SpringCloud%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/image-20221016182153089.png" alt="image-20221016182153089" style="zoom:50%;" />

<p>交换机列表中自动为我们新增了刚刚创建好的虚拟主机相关的预设交换机，一共7个，这里我们首先介绍一下前面两个<code>direct</code>类型的交换机，一个是<code>（AMQP default）</code>还有一个是<code>amq.direct</code>，它们都是直连模式的交换机，我们来看看第一个：</p>
<h4 id="（1）Exchange-AMQP-default"><a href="#（1）Exchange-AMQP-default" class="headerlink" title="（1）Exchange: (AMQP default)"></a>（1）Exchange: (AMQP default)</h4><p>第一个交换机是所有虚拟主机都会自带的一个默认交换机，并且此交换机不可删除，<strong>此交换机默认绑定到所有的消息队列</strong>，如果是通过默认交换机发送消息，那么会<strong>根据消息的<code>routingKey</code><strong>（之后我们发消息都会指定）</strong>决定发送到目标名称的消息队列</strong>，同时也不能显示地将消息队列绑定或解绑到此交换机。</p>
<p>默认交换机特性是<strong>持久化</strong>的（Features），也就是说就算机器重启，那么此交换机也会保留，如果不是持久化，那么一旦重启就会消失。实际上我们在列表中看到<code>D</code>的字样，就表示此交换机是持久化的，包含一会我们要讲解的消息队列列表也是这样，所有自动生成的交换机都是持久化的。</p>
<p>我们接着来看第二个交换机，这个交换机是一个普通的直连交换机：</p>
<h4 id="（2）Exchange-amq-direct"><a href="#（2）Exchange-amq-direct" class="headerlink" title="（2）Exchange: amq.direct"></a>（2）Exchange: amq.direct</h4><p>这个交换机和我们刚刚介绍的默认交换机类型一致，并且也是持久化的，但是我们可以看到它是具有绑定关系的，<strong>如果没有指定的消息队列绑定到此交换机上，那么这个交换机无法正常将信息存放到指定的消息队列中</strong>，也是根据<code>routingKey</code>寻找消息队列（但是可以自定义）（消息队列需要手动绑定到此交换机）</p>
<p>1、首先，新建消息队列，在 Queues 栏目：</p>
<p>选择刚刚创建好的虚拟主机，在这个虚拟主机下创建此消息队列，接着我们将其类型定义为<code>Classic</code>类型，也就是经典类型（其他类型我们会在后面逐步介绍）名称随便起一个，然后持久化我们选择<code>Transient</code>暂时的（当然也可以持久化，看你自己）自动删除我们选择<code>No</code>（需要至少有一个消费者连接到这个队列，之后，一旦所有与这个队列连接的消费者都断开时，就会自动删除此队列）最下面的参数我们暂时不进行任何设置（之后会用到）</p>
<p>点击此队列的名称，我们可以查看详细信息；详细相信中包括队列的当前负载状态、属性、消息队列占用的内存，消息数量等，一会我们发送消息时可以进一步进行观察。</p>
<p>2、现在我们需要将此消息队列绑定到上面的第二个直连交换机，这样我们就可以通过此交换机向此消息队列发送消息了。</p>
<p>在队列上新增绑定信息，routingkey这里设置为 my-yyds，交换机指定为上面的第二个直连交换机：</p>
<img src="../images/SpringCloud%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/image-20221016194427071.png" alt="image-20221016194427071" style="zoom:80%;" />

<p>3、在交换机处绑定队列处看到绑定信息；</p>
<p>在 Publish message 使用刚刚的 routingkey：</p>
<img src="../images/SpringCloud%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/image-20221016195104606.png" alt="image-20221016195104606" style="zoom:80%;" />

<p>之后点击 publish message，提示Message published.</p>
<p>4、在Queues栏目看到消息发送信息、消息发送速率：</p>
<img src="../images/SpringCloud%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/image-20221016195256633.png" alt="image-20221016195256633" style="zoom:67%;" />

<p>Queues栏目和Exchanges栏目发消息的区别：</p>
<p>​        <u>Queues栏目下的publish message是不会经过交换机直接发送到队列的，而刚刚上一步在 Exchanges栏目下publish message是经过交换机发送到队列。</u></p>
<p>5、我们可以直接在消息队列这边<strong>获取消息队列中的消息</strong>，找到下方的Get message选项：</p>
<img src="../images/SpringCloud%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/image-20221016214105856.png" alt="image-20221016214105856" style="zoom: 80%;" />

<p>可以看到有三个选择，首先第一个Ack Mode，这个是应答模式选择，一共有4个选项：</p>
<ul>
<li>Nack message requeue true：拒绝消息，也就是说<strong>不会将消息从消息队列取出</strong>，并且重新排队，一次可以拒绝多个消息。</li>
<li>Ack message requeue false：确认应答，确认后消息会<strong>从消息队列中移除</strong>，一次可以确认多个消息。</li>
<li>Reject message requeue true/false：也是拒绝此消息，但是可以指定是否重新排队。</li>
</ul>
<p>最后如果我们不需要再使用此消息队列了，我们可以手动对其进行删除或是清空：Delete / Purge。</p>
<h3 id="1-1、SpringBoot整合消息队列客户端"><a href="#1-1、SpringBoot整合消息队列客户端" class="headerlink" title="1.1、SpringBoot整合消息队列客户端"></a>1.1、SpringBoot整合消息队列客户端</h3><p>（1）首先导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）接着需要配置Spring RabbitMQ：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">addresses:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.4</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/test</span>  <span class="comment">#之前的 VirtualHost</span></span><br></pre></td></tr></table></figure>

<p>（3）这样我们就完成了最基本信息配置，现在想要像之前一样去声明一个消息队列，我们只需要一个配置类：（定义交换机、队列以及绑定）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(&quot;directExchange&quot;)</span>  <span class="comment">//定义交换机Bean，可以很多个</span></span><br><span class="line">    <span class="keyword">public</span> Exchange <span class="title function_">exchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(<span class="string">&quot;amq.direct&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;yydsQueue&quot;)</span>     <span class="comment">//定义消息队列</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder</span><br><span class="line">          				.nonDurable(<span class="string">&quot;yyds&quot;</span>)   <span class="comment">//非持久化类型</span></span><br><span class="line">          				.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;binding&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">binding</span><span class="params">(<span class="meta">@Qualifier(&quot;directExchange&quot;)</span> Exchange exchange,</span></span><br><span class="line"><span class="params">                           <span class="meta">@Qualifier(&quot;yydsQueue&quot;)</span> Queue queue)</span>&#123;</span><br><span class="line">      	<span class="comment">//将我们刚刚定义的交换机和队列进行绑定</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder</span><br><span class="line">                .bind(queue)   <span class="comment">//绑定队列</span></span><br><span class="line">                .to(exchange)  <span class="comment">//到交换机</span></span><br><span class="line">                .with(<span class="string">&quot;my-yyds&quot;</span>)   <span class="comment">//使用自定义的routingKey</span></span><br><span class="line">                .noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）简单String消息的发送：我们定义一个生产者，这里直接编写在测试用例中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringCloudMqApplicationTests</span> &#123;</span><br><span class="line">  	<span class="comment">//RabbitTemplate为我们封装了大量的RabbitMQ操作，已经由Starter提供，因此直接注入使用即可</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    RabbitTemplate template;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">publisher</span><span class="params">()</span> &#123;</span><br><span class="line">      	<span class="comment">//使用convertAndSend方法一步到位，参数基本和之前是一样的</span></span><br><span class="line">      	<span class="comment">//最后一个消息本体可以是Object类型，真是大大的方便</span></span><br><span class="line">        template.convertAndSend(<span class="string">&quot;amq.direct&quot;</span>, <span class="string">&quot;my-yyds&quot;</span>, <span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再来看看如何创建一个消费者，因为消费者实际上就是一直等待消息然后进行处理的角色，这里我们只需要创建一个监听器就行了，它会一直等待消息到来然后再进行处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>  <span class="comment">//注册为Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;yyds&quot;)</span>   <span class="comment">//定义此方法为队列yyds的监听器，一旦监听到新的消息，就会接受并处理</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Message message)</span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（5）如果需要确保消息能够被消费者接受并处理，然后得到消费者的反馈，也是可以的（convertSendAndReceive方法）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">publisher</span><span class="params">()</span> &#123;  <span class="comment">//生产者</span></span><br><span class="line">  	<span class="comment">//会等待消费者消费然后返回响应结果</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> template.convertSendAndReceive(<span class="string">&quot;amq.direct&quot;</span>, <span class="string">&quot;my-yyds&quot;</span>, <span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;收到消费者响应：&quot;</span>+res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者这边只需要返回一个对应的结果即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;yyds&quot;)</span>  <span class="comment">//消费者</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">receiver</span><span class="params">(String data)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;一号消息队列监听器 &quot;</span>+data);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;收到!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（6）如果我们需要直接接收一个JSON格式的消息，并且希望直接获取到实体类呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfiguration</span> &#123;</span><br><span class="line">  	...</span><br><span class="line">    <span class="meta">@Bean(&quot;jacksonConverter&quot;)</span>   <span class="comment">//直接创建一个用于JSON转换的Bean</span></span><br><span class="line">    <span class="keyword">public</span> Jackson2JsonMessageConverter <span class="title function_">converter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们只需要指定转换器就可以了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestListener</span> &#123;</span><br><span class="line">  	<span class="comment">//指定messageConverter为我们刚刚创建的Bean名称</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;yyds&quot;, messageConverter = &quot;jacksonConverter&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiver</span><span class="params">(User user)</span>&#123;  <span class="comment">//直接接收User类型</span></span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们直接在管理页面发送：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;LB&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/e6c9d24ely1h1byhcakabj221m0lwac0.jpg" alt="image-20220416225912100"></p>
<p>可以在idea控制台看到成功完成了转换，并输出了用户对象的信息。</p>
<h3 id="1-2、死信队列"><a href="#1-2、死信队列" class="headerlink" title="1.2、死信队列"></a>1.2、死信队列</h3><p>消息队列中的数据，如果迟迟没有消费者来处理，那么就会一直占用消息队列的空间。比如我们模拟一下抢车票的场景，用户下单高铁票之后，会进行抢座，然后再进行付款，但是如果用户下单之后并没有及时的付款，这张票不可能一直让这个用户占用着，因为你不买别人还要买呢，所以会在一段时间后超时，让这张票可以继续被其他人购买。</p>
<p>这时，我们就可以使用死信队列，将那些用户超时未付款的或是用户主动取消的订单，进行进一步的处理，以下类型的消息都会被判定为死信：</p>
<ul>
<li>消息被拒绝(basic.reject / basic.nack)，并且requeue = false</li>
<li>消息达到TTL过期时间未消费</li>
<li>队列达到最大长度</li>
</ul>
<p>那么如何构建这样的一种使用模式呢？实际上本质就是一个死信交换机+绑定的死信队列，当正常队列中的消息被判定为死信时，会被发送到对应的死信交换机，然后再通过交换机发送到死信队列中，死信队列也有对应的消费者去处理消息。</p>
<h3 id="2、工作队列模式"><a href="#2、工作队列模式" class="headerlink" title="2、工作队列模式"></a>2、工作队列模式</h3><p><strong>注意：</strong>XX模式只是一种设计思路，并不是指的具体的某种实现，可以理解为实现XX模式需要怎么去写。</p>
<p>前面我们了解了最简的一个消费者一个生产者的模式，接着我们来了解一下一个生产者多个消费者的情况：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/e6c9d24egy1h1g7hh8h18j21he06mt8x.jpg" alt="image-20220420151258324"></p>
<p>实际上这种模式就非常适合多个工人等待新的任务到来的场景，我们的任务有很多个，一个一个丢进消息队列，而此时工人有很多个，那么我们就可以将这些任务分配个各个工人，让他们各自负责一些任务，并且做的快的工人还可以做完成一些（<strong>能者多劳</strong>）。</p>
<p>非常简单，我们只需要创建两个监听器即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestListener</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;yyds&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiver</span><span class="params">(String data)</span>&#123;   <span class="comment">//这里直接接收String类型的数据</span></span><br><span class="line">        System.out.println(<span class="string">&quot;一号消息队列监听器 &quot;</span>+data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;yyds&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiver2</span><span class="params">(String data)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;二号消息队列监听器 &quot;</span>+data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送消息时，会自动进行轮询分发。</p>
<h3 id="3、发布订阅模式（fanout类型交换机）"><a href="#3、发布订阅模式（fanout类型交换机）" class="headerlink" title="3、发布订阅模式（fanout类型交换机）"></a>3、发布订阅模式（fanout类型交换机）</h3><p>前面我们已经了解了RabbitMQ客户端的一些基本操作，包括普通的消息模式，接着我们来了解一下其他的模式，首先是发布订阅模式，它支持多种方式：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/e6c9d24egy1h1gb8mwfc9j21gy08emxj.jpg" alt="image-20220420172252440"></p>
<p>比如我们在阿里云买了云服务器，但是最近快到期了，那么就会给你的手机、邮箱发送消息，告诉你需要去续费了，但是手机短信和邮件发送并不一定是同一个业务提供的，但是现在我们又希望能够都去执行，所以就可以用到发布订阅模式，简而言之就是，<strong>发布一次，消费多个。</strong></p>
<p>实现这种模式其实也非常简单，但是如果使用我们之前的直连交换机，肯定是不行的，我们这里需要用到另一种类型的交换机，叫做**<code>fanout</code>（扇出）类型<strong>，</strong>这是一种广播类型，消息会被广播到所有与此交换机绑定的消息队列中**。</p>
<h3 id="4、路由模式（routing）"><a href="#4、路由模式（routing）" class="headerlink" title="4、路由模式（routing）"></a>4、路由模式（routing）</h3><p>路由模式实际上我们一开始就已经实现了，我们可以在绑定时指定想要的<code>routingKey</code>只有生产者发送时指定了对应的<code>routingKey</code>才能到达对应的队列。</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/e6c9d24ely1h1glt0bescj21dk08mjru.jpg" alt="image-20220420232826848"></p>
<p>当然除了我们之前的一次绑定之外，同一个消息队列可以多次绑定到交换机，并且使用不同的<code>routingKey</code>，这样只要满足其中一个都可以被发送到此消息队列中。</p>
<h3 id="5、主题模式（topic）（topic类型交换机）"><a href="#5、主题模式（topic）（topic类型交换机）" class="headerlink" title="5、主题模式（topic）（topic类型交换机）"></a>5、主题模式（topic）（topic类型交换机）</h3><p>实际上这种模式就是一种模糊匹配的模式，我们可以将<code>routingKey</code>以模糊匹配的方式去进行转发。</p>
<p>我们可以使用<code>*</code>或<code>#</code>来表示：</p>
<ul>
<li>* - 表示任意的一个单词</li>
<li># - 表示0个或多个单词</li>
</ul>
<p>这里我们来测试一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;topicExchange&quot;)</span>  <span class="comment">//这里使用预置的Topic类型交换机</span></span><br><span class="line">    <span class="keyword">public</span> Exchange <span class="title function_">exchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.topicExchange(<span class="string">&quot;amq.topic&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;yydsQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.nonDurable(<span class="string">&quot;yyds&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;binding&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">binding2</span><span class="params">(<span class="meta">@Qualifier(&quot;topicExchange&quot;)</span> Exchange exchange,</span></span><br><span class="line"><span class="params">                           <span class="meta">@Qualifier(&quot;yydsQueue&quot;)</span> Queue queue)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder</span><br><span class="line">                .bind(queue)</span><br><span class="line">                .to(exchange)</span><br><span class="line">                .with(<span class="string">&quot;*.test.*&quot;</span>)</span><br><span class="line">                .noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动项目，可以看到只要是满足通配符条件的都可以成功转发到对应的消息队列。</p>
<h3 id="6、第四种交换机类型（header类型交换机）"><a href="#6、第四种交换机类型（header类型交换机）" class="headerlink" title="6、第四种交换机类型（header类型交换机）"></a>6、第四种交换机类型（header类型交换机）</h3><p>通过前面的学习，我们已经介绍了三种交换机类型，现在我们来介绍一下第四种交换机类型<code>header</code>，它是根据头部信息来决定的，在我们发送的消息中是可以携带一些头部信息的（类似于HTTP），我们可以根据这些头部信息来决定路由到哪一个消息队列中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;headerExchange&quot;)</span>  <span class="comment">//注意这里返回的是HeadersExchange</span></span><br><span class="line">    <span class="keyword">public</span> HeadersExchange <span class="title function_">exchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder</span><br><span class="line">                .headersExchange(<span class="string">&quot;amq.headers&quot;</span>)  <span class="comment">//RabbitMQ为我们预置了两个，这里用第一个就行</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;yydsQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.nonDurable(<span class="string">&quot;yyds&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;binding&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">binding2</span><span class="params">(<span class="meta">@Qualifier(&quot;headerExchange&quot;)</span> HeadersExchange exchange,  //这里和上面一样的类型</span></span><br><span class="line"><span class="params">                           <span class="meta">@Qualifier(&quot;yydsQueue&quot;)</span> Queue queue)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder</span><br><span class="line">                .bind(queue)</span><br><span class="line">                .to(exchange)   <span class="comment">//使用HeadersExchange的to方法，可以进行进一步配置</span></span><br><span class="line">          			<span class="comment">//.whereAny(&quot;a&quot;, &quot;b&quot;).exist();   这个是只要存在任意一个指定的头部Key就行</span></span><br><span class="line">                <span class="comment">//.whereAll(&quot;a&quot;, &quot;b&quot;).exist();   这个是必须存在所有指定的的头部Key</span></span><br><span class="line">                .where(<span class="string">&quot;test&quot;</span>).matches(<span class="string">&quot;hello&quot;</span>);   <span class="comment">//比如我们现在需要消息的头部信息中包含test，并且值为hello才能转发给我们的消息队列</span></span><br><span class="line">      					<span class="comment">//.whereAny(Collections.singletonMap(&quot;test&quot;, &quot;hello&quot;)).match();  传入Map也行，批量指定键值对</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h3><p>前面对于RabbitMQ的相关内容已经基本讲解完了，最后尝试搭建集群，让RabbitMQ之间进行数据复制（镜像模式）。可能会用到的一些命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo rabbitmqctl stop_app</span><br><span class="line">sudo rabbitmqctl join_cluster rabbit@ubuntu-server</span><br><span class="line">sudo rabbitmqctl start_app</span><br></pre></td></tr></table></figure>

<h2 id="SpringCloud-消息组件"><a href="#SpringCloud-消息组件" class="headerlink" title="SpringCloud 消息组件"></a>SpringCloud 消息组件</h2><h3 id="1、SpringCloud-Stream"><a href="#1、SpringCloud-Stream" class="headerlink" title="1、SpringCloud Stream"></a>1、SpringCloud Stream</h3><p><strong>官方文档：</strong><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-cloud-stream/docs/3.2.2/reference/html/">https://docs.spring.io/spring-cloud-stream/docs/3.2.2/reference/html/</a></p>
<p>前面我们介绍了RabbitMQ，了解了消息队列相关的一些操作，但是可能我们会遇到不同的系统在用不同的消息队列，比如系统A用的Kafka、系统B用的RabbitMQ，但是我们现在又没有学习过Kafka，那么怎么办呢？有没有一种方式像JDBC一样，我们只需要关心SQL和业务本身，而不用关心数据库的具体实现呢？</p>
<p>SpringCloud Stream能够做到，它能够<strong>屏蔽底层实现，我们使用统一的消息队列操作方式就能操作多种不同类型的消息队列</strong>。它屏蔽了RabbitMQ底层操作，让我们使用统一的Input和Output形式，以Binder为中间件，这样就算我们切换了不同的消息队列，也无需修改代码，而具体某种消息队列的底层实现是交给Stream在做的。</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/e6c9d24ely1h1hqdnqlqsj21iu0l0myd.jpg" alt="image-20220421225215709"></p>
<p>这里创建一个项目测试：</p>
<img src="../images/SpringCloud%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/image-20221023002855445.png" alt="image-20221023002855445" style="zoom: 80%;" />

<p>依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2021.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  RabbitMQ的Stream实现  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>首先是生产者，配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8001</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="attr">binders:</span>   <span class="comment">#此处配置要绑定的rabbitmq的服务信息</span></span><br><span class="line">        <span class="attr">local-server:</span> <span class="comment">#绑定名称，随便起一个就行</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">rabbit</span> <span class="comment">#消息组件类型，这里使用的是RabbitMQ，就填写rabbit</span></span><br><span class="line">          <span class="attr">environment:</span>  <span class="comment">#服务器相关信息，按照下面的方式填写就行，爆红别管</span></span><br><span class="line">            <span class="attr">spring:</span></span><br><span class="line">              <span class="attr">rabbitmq:</span></span><br><span class="line">                <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">                <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">                <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">                <span class="attr">password:</span> <span class="string">admin</span></span><br><span class="line">                <span class="attr">virtual-host:</span> <span class="string">/test</span></span><br><span class="line">      <span class="attr">bindings:</span></span><br><span class="line">        <span class="attr">test-out-0:</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">test.exchange</span></span><br></pre></td></tr></table></figure>

<p>接着我们来编写一个Controller，一会访问一次这个接口，就向消息队列发送一个数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.stream.function.StreamBridge;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PublishController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    StreamBridge bridge;  <span class="comment">//通过bridge来发送消息</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/publish&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">publish</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//第一个参数其实就是RabbitMQ的交换机名称（数据会发送给这个交换机，到达哪个消息队列，不由我们决定）</span></span><br><span class="line">       <span class="comment">//这个交换机的命名稍微有一些规则:</span></span><br><span class="line">       <span class="comment">//输入:    &lt;名称&gt; + -in- + &lt;index&gt;</span></span><br><span class="line">       <span class="comment">//输出:    &lt;名称&gt; + -out- + &lt;index&gt;</span></span><br><span class="line">       <span class="comment">//这里我们使用输出的方式，来将数据发送到消息队列，注意这里的名称会和之后的消费者Bean名称进行对应</span></span><br><span class="line">        bridge.send(<span class="string">&quot;test-out-0&quot;</span>, <span class="string">&quot;HelloWorld!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;消息发送成功！&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动SpringBoot项目，访问接口：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/image-20221023003111169.png" alt="image-20221023003111169"></p>
<p>新增了一个<code>test-in-0</code>交换机，并且此交换机是topic类型的：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/image-20221023003319486.png" alt="image-20221023003319486"></p>
<p>但是目前没有任何队列绑定到此交换机上，因此我们刚刚发送的消息实际上是没有给到任何队列的。</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/image-20221023003327728.png" alt="image-20221023003327728"></p>
<p>接着我们来编写一下消费者，消费者的编写方式比较特别，只需要定义一个Consumer就可以了，其他配置保持一致：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8002</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="attr">binders:</span>   <span class="comment">#此处配置要绑定的rabbitmq的服务信息</span></span><br><span class="line">        <span class="attr">local-server:</span> <span class="comment">#绑定名称，随便起一个就行</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">rabbit</span> <span class="comment">#消息组件类型，这里使用的是RabbitMQ，就填写rabbit</span></span><br><span class="line">          <span class="attr">environment:</span>  <span class="comment">#服务器相关信息，按照下面的方式填写就行，爆红别管</span></span><br><span class="line">            <span class="attr">spring:</span></span><br><span class="line">              <span class="attr">rabbitmq:</span></span><br><span class="line">                <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">                <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">                <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">                <span class="attr">password:</span> <span class="string">admin</span></span><br><span class="line">                <span class="attr">virtual-host:</span> <span class="string">/test</span></span><br><span class="line">      <span class="attr">bindings:</span></span><br><span class="line">        <span class="comment">#因为消费者是输入，默认名称为 方法名-in-index，这里我们将其指定为我们刚刚定义的交换机</span></span><br><span class="line">        <span class="attr">test-in-0:</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">test.exchange</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;test&quot;)</span>   <span class="comment">//注意这里需要填写我们前面交换机名称中&quot;名称&quot;，这样生产者发送的数据才会正确到达</span></span><br><span class="line">    <span class="keyword">public</span> Consumer&lt;String&gt; <span class="title function_">consumer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.out::println;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们直接启动就可以了，可以看到启动之后，自动为我们创建了一个新的队列：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/image-20221023003718382.png" alt="image-20221023003718382"></p>
<p>而这个队列实际上就是我们消费者等待数据到达的队列：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/image-20221023003805707.png" alt="image-20221023003805707"></p>
<p>可以看到当前队列直接绑定到了我们刚刚创建的交换机上，并且<code>routingKey</code>是直接写的<code>#</code>，也就是说一会消息会直接过来。</p>
<p>现在再来访问一下消息发送接口：</p>
<p><a target="_blank" rel="noopener" href="http://localhost:8001/publish">http://localhost:8001/publish</a></p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/image-20221023010714638.png" alt="image-20221023010714638"></p>
<p>消息消费成功：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/image-20221023010740028.png" alt="image-20221023010740028"></p>
<p>这样，我们就通过使用SpringCloud Stream来屏蔽掉底层RabbitMQ来直接进行消息的操作了。</p>
<h3 id="2、SpringCloud-Bus"><a href="#2、SpringCloud-Bus" class="headerlink" title="2、SpringCloud Bus"></a>2、SpringCloud Bus</h3><p><strong>官方文档：</strong><a target="_blank" rel="noopener" href="https://cloud.spring.io/spring-cloud-bus/reference/html/">https://cloud.spring.io/spring-cloud-bus/reference/html/</a></p>
<p>实际上它就相当于是一个消息总线，可用于向各个服务广播某些状态的更改（比如云端配置更改，可以结合Config组件实现动态更新配置，当然我们前面学习的Nacos其实已经包含这个功能了）或其他管理指令。</p>
<p>这里我们也是简单使用一下吧，Bus需要基于一个具体的消息队列实现，比如RabbitMQ或是Kafka，这里我们依然使用RabbitMQ。</p>
<p>我们将最开始的微服务拆分项目继续使用，比如现在我们希望借阅服务的某个接口调用时，能够给用户服务和图书服务发送一个通知，首先是依赖：</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">lcq</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/post/92c4b7db.html">http://example.com/post/92c4b7db.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/SpringCloud/">SpringCloud</a></div><div class="post_share"><div class="social-share" data-image="https://iw233.cn/api.php?sort=pc" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> Donate</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg"/></a><div class="post-qr-code-desc"></div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg"/></a><div class="post-qr-code-desc"></div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/undefined.html"><img class="prev-cover" src="https://iw233.cn/api.php?sort=pc" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Centos7教程</div></div></a></div><div class="next-post pull-right"><a href="/post/c9acdb25.html"><img class="next-cover" src="https://iw233.cn/api.php?sort=pc" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">负载均衡</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/post/c9acdb25.html" title="负载均衡"><img class="cover" src="https://iw233.cn/api.php?sort=pc" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-06</div><div class="title">负载均衡</div></div></a></div><div><a href="/post/67c8035e.html" title="SpringCloud笔记"><img class="cover" src="https://iw233.cn/api.php?sort=pc" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-23</div><div class="title">SpringCloud笔记</div></div></a></div><div><a href="/post/2a78d0be.html" title="SpringCloud笔记（2）"><img class="cover" src="https://iw233.cn/api.php?sort=pc" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-26</div><div class="title">SpringCloud笔记（2）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">lcq</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">30</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">15</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/lcqlcqq" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">1.</span> <span class="toc-text">微服务中间件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.1.</span> <span class="toc-text">消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.1.1.</span> <span class="toc-text">RabbitMQ 消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%AE%89%E8%A3%85erlang"><span class="toc-number">1.1.2.</span> <span class="toc-text">一、安装erlang</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AE%89%E8%A3%85RabbitMQ"><span class="toc-number">1.1.3.</span> <span class="toc-text">二、安装RabbitMQ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%B5%8B%E8%AF%95%E7%99%BB%E5%BD%95"><span class="toc-number">1.1.4.</span> <span class="toc-text">三、测试登录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ-%E6%9E%B6%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">RabbitMQ 架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Exchange-%E4%BA%A4%E6%8D%A2%E6%9C%BA-%E8%AF%A6%E8%A7%A3%EF%BC%9A"><span class="toc-number">1.2.1.</span> <span class="toc-text">Exchange(交换机)详解：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">交换机类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ-%E7%9A%84%E5%85%AD%E7%A7%8D%E6%B6%88%E6%81%AF%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">RabbitMQ 的六种消息模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%AE%80%E5%8D%95%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E6%A8%A1%E5%BC%8F%EF%BC%9A%EF%BC%88direct%E7%B1%BB%E5%9E%8B%E4%BA%A4%E6%8D%A2%E6%9C%BA%EF%BC%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">1、简单工作队列模式：（direct类型交换机）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89Exchange-AMQP-default"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">（1）Exchange: (AMQP default)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89Exchange-amq-direct"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">（2）Exchange: amq.direct</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E3%80%81SpringBoot%E6%95%B4%E5%90%88%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.3.2.</span> <span class="toc-text">1.1、SpringBoot整合消息队列客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%E3%80%81%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="toc-number">1.3.3.</span> <span class="toc-text">1.2、死信队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.4.</span> <span class="toc-text">2、工作队列模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%EF%BC%88fanout%E7%B1%BB%E5%9E%8B%E4%BA%A4%E6%8D%A2%E6%9C%BA%EF%BC%89"><span class="toc-number">1.3.5.</span> <span class="toc-text">3、发布订阅模式（fanout类型交换机）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%EF%BC%88routing%EF%BC%89"><span class="toc-number">1.3.6.</span> <span class="toc-text">4、路由模式（routing）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E4%B8%BB%E9%A2%98%E6%A8%A1%E5%BC%8F%EF%BC%88topic%EF%BC%89%EF%BC%88topic%E7%B1%BB%E5%9E%8B%E4%BA%A4%E6%8D%A2%E6%9C%BA%EF%BC%89"><span class="toc-number">1.3.7.</span> <span class="toc-text">5、主题模式（topic）（topic类型交换机）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E7%AC%AC%E5%9B%9B%E7%A7%8D%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B%EF%BC%88header%E7%B1%BB%E5%9E%8B%E4%BA%A4%E6%8D%A2%E6%9C%BA%EF%BC%89"><span class="toc-number">1.3.8.</span> <span class="toc-text">6、第四种交换机类型（header类型交换机）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA"><span class="toc-number">1.3.9.</span> <span class="toc-text">集群搭建</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringCloud-%E6%B6%88%E6%81%AF%E7%BB%84%E4%BB%B6"><span class="toc-number">1.4.</span> <span class="toc-text">SpringCloud 消息组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81SpringCloud-Stream"><span class="toc-number">1.4.1.</span> <span class="toc-text">1、SpringCloud Stream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81SpringCloud-Bus"><span class="toc-number">1.4.2.</span> <span class="toc-text">2、SpringCloud Bus</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/d28eb4ae.html" title="启动单机nacos+sentinel+seata">启动单机nacos+sentinel+seata</a><time datetime="2023-01-09T07:02:34.000Z" title="Created 2023-01-09 15:02:34">2023-01-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/ed551fa.html" title="日志与日志框架">日志与日志框架</a><time datetime="2023-01-09T06:14:28.000Z" title="Created 2023-01-09 14:14:28">2023-01-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/a2d3b88e.html" title="Redis从入门到入土（">Redis从入门到入土（</a><time datetime="2022-11-11T09:14:25.000Z" title="Created 2022-11-11 17:14:25">2022-11-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/undefined.html" title="Centos7教程">Centos7教程</a><time datetime="2022-11-08T08:26:26.000Z" title="Created 2022-11-08 16:26:26">2022-11-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/92c4b7db.html" title="SpringCloud笔记（3）">SpringCloud笔记（3）</a><time datetime="2022-10-16T08:24:03.000Z" title="Created 2022-10-16 16:24:03">2022-10-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By lcq</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>