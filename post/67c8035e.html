<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>SpringCloud笔记 | Syerenc</title><meta name="keywords" content="SpringCloud"><meta name="author" content="lcq"><meta name="copyright" content="lcq"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="微服务基础微服务相比传统单体应用（SpringBoot）：随着越来越多的功能不断地加入到一个SpringBoot项目中，随着接口不断增加，整个系统就要在同一时间内响应更多类型的请求。并且所有的功能如果都集成在单端上，那么所有的请求都会全部汇集到一台服务器上，对此服务器造成巨大压力。尤其是一台服务器无法承受庞大的单体应用部署，并且单体应用的维护也会越来越困难，我们得寻找一种新的开发架构来解决这些问题">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringCloud笔记">
<meta property="og:url" content="http://example.com/post/67c8035e.html">
<meta property="og:site_name" content="Syerenc">
<meta property="og:description" content="微服务基础微服务相比传统单体应用（SpringBoot）：随着越来越多的功能不断地加入到一个SpringBoot项目中，随着接口不断增加，整个系统就要在同一时间内响应更多类型的请求。并且所有的功能如果都集成在单端上，那么所有的请求都会全部汇集到一台服务器上，对此服务器造成巨大压力。尤其是一台服务器无法承受庞大的单体应用部署，并且单体应用的维护也会越来越困难，我们得寻找一种新的开发架构来解决这些问题">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://iw233.cn/api.php?sort=pc">
<meta property="article:published_time" content="2022-07-23T07:04:04.000Z">
<meta property="article:modified_time" content="2022-07-25T11:03:30.926Z">
<meta property="article:author" content="lcq">
<meta property="article:tag" content="SpringCloud">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://iw233.cn/api.php?sort=pc"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/post/67c8035e"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'SpringCloud笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-07-25 19:03:30'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/source/css/jianbian.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"> <script src="/live2d-widget/autoload.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">6</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://iw233.cn/api.php?sort=pc')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Syerenc</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">SpringCloud笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-07-23T07:04:04.000Z" title="Created 2022-07-23 15:04:04">2022-07-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-07-25T11:03:30.926Z" title="Updated 2022-07-25 19:03:30">2022-07-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/SpringCloud/">SpringCloud</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">12.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>43min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="SpringCloud笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="微服务基础"><a href="#微服务基础" class="headerlink" title="微服务基础"></a>微服务基础</h2><p>微服务相比传统单体应用（SpringBoot）：随着越来越多的功能不断地加入到一个SpringBoot项目中，随着接口不断增加，整个系统就要在同一时间内响应更多类型的请求。并且所有的功能如果都集成在单端上，那么所有的请求都会全部汇集到一台服务器上，对此服务器造成巨大压力。尤其是一台服务器无法承受庞大的单体应用部署，并且单体应用的维护也会越来越困难，我们得寻找一种新的开发架构来解决这些问题了。</p>
<p>Martin Fowler在2014年提出了“微服务”架构，它是一种全新的架构风格。</p>
<ul>
<li>微服务把一个庞大的单体应用拆分为一个个的小型服务，比如我们原来的图书管理项目中，有登录、注册、添加、删除、搜索等功能，那么我们可以将这些功能单独做成一个个小型的SpringBoot项目，独立运行。</li>
<li>每个小型的微服务，都可以独立部署和升级，这样，就算整个系统崩溃，那么也只会影响一个服务的运行。</li>
<li>微服务之间使用HTTP进行数据交互，不再是单体应用内部交互了，虽然这样会显得更麻烦，但是带来的好处也是很直接的，甚至能突破语言限制，使用不同的编程语言进行微服务开发，只需要使用HTTP进行数据交互即可。</li>
<li>我们可以同时购买多台主机来分别部署这些微服务，这样，单机的压力就被分散到多台机器，并且每台机器的配置不一定需要太高，这样就能节省大量的成本，同时安全性也得到很大的保证。</li>
<li>甚至同一个微服务可以同时存在多个，这样当其中一个服务器出现问题时，其他服务器也在运行同样的微服务，这样就可以保证一个微服务的<strong>高可用</strong>。</li>
</ul>
<h3 id="（1）走进SpringCloud"><a href="#（1）走进SpringCloud" class="headerlink" title="（1）走进SpringCloud"></a>（1）走进SpringCloud</h3><p>前面介绍了微服务架构的优点，那么同样的，这些优点的背后也存在着诸多的问题：</p>
<ul>
<li>要实现微服务并不是说只需要简单地将项目进行拆分，我们还需要考虑对各个微服务进行管理、监控等，这样我们才能够及时地寻找和排查问题。因此微服务往往需要的是<strong>一整套解决方案</strong>，包括服务注册和发现、容灾处理、负载均衡、配置管理等。</li>
<li>它不像单体架构那种方便维护，由于部署在多个服务器，我们不得不去保证各个微服务能够稳定运行，在管理难度上肯定是高于传统单体应用的。</li>
<li>在分布式的环境下，单体应用的某些功能可能会变得比较麻烦，比如分布式事务。</li>
</ul>
<p>所以，为了更好地解决这些问题，SpringCloud正式登场。</p>
<p><strong>SpringCloud是Spring提供的一套分布式解决方案，集合了一些大型互联网公司的开源产品，包括诸多组件，共同组成SpringCloud框架。并且，它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、熔断机制、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。</strong></p>
<p>由于中小型公司没有独立开发自己的分布式基础设施的能力，使用SpringCloud解决方案能够以最低的成本应对当前时代的业务发展。</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24egy1h0ig93rk52j21ss0nytbj.jpg" alt="image-20220322102706256"></p>
<p>可以看到，SpringCloud整体架构的亮点是非常明显的，分布式架构下的各个场景，都有对应的组件来处理，比如基于Netflix（奈飞）的开源分布式解决方案提供的组件：</p>
<ul>
<li>Eureka  -  实现服务治理（服务注册与发现），我们可以对所有的微服务进行集中管理，包括他们的运行状态、信息等。</li>
<li>Ribbon  -  为服务之间相互调用提供负载均衡算法（现在被SpringCloudLoadBalancer取代）</li>
<li>Hystrix  -  断路器，保护系统，控制故障范围。暂时可以跟家里电闸的保险丝类比，当触电危险发生时能够防止进一步的发展。</li>
<li>Zuul   -     api网关，路由，负载均衡等多种作用，就像我们的路由器，可能有很多个设备都连接了路由器，但是数据包要转发给谁则是由路由器在进行（已经被SpringCloudGateway取代）</li>
<li>Config  -  配置管理，可以实现配置文件集中管理</li>
</ul>
<p>当然，这里只是进行简单的了解即可，实际上微服务的玩法非常多，我们后面的学习中将会逐步进行探索。那么首先，我们就从注册中心开始说起。</p>
<h3 id="（2）Eureka-注册中心"><a href="#（2）Eureka-注册中心" class="headerlink" title="（2）Eureka 注册中心"></a>（2）Eureka 注册中心</h3><p>官方文档：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-cloud-netflix/docs/current/reference/html/">https://docs.spring.io/spring-cloud-netflix/docs/current/reference/html/</a></p>
<h4 id="微服务结构"><a href="#微服务结构" class="headerlink" title="微服务结构"></a>微服务结构</h4><p>现在我们重新设计一下之前的图书管理系统项目，将原有的大型项目进行拆分，注意项目拆分一定要尽可能保证<strong>单一职责，相同的业务不要在多个微服务中重复出现</strong>，如果出现需要借助其他业务完成的服务，那么可以使用服务之间相互调用的形式来实现（之后会介绍）：</p>
<ul>
<li>登录验证服务：用于处理用户注册、登录、密码重置等，反正就是一切与账户相关的内容，包括用户信息获取等。</li>
<li>图书管理服务：用于进行图书添加、删除、更新等操作，图书管理相关的服务，包括图书的存储等和信息获取。</li>
<li>图书借阅服务：交互性比较强的服务，需要和登陆验证服务和图书管理服务进行交互。</li>
</ul>
<p>那么既然要将单体应用拆分为多个小型服务，我们就需要重新设计一下整个项目目录结构，这里我们就创建多个子项目，每一个子项目都是一个服务，这样由父项目统一管理依赖，就无需每个子项目都去单独管理依赖了，也更方便一点。</p>
<p>简单微服务架构：Spring项目作为父工程，新建多个maven模块作为服务模块：</p>
<img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/image-20220724125515855.png" alt="image-20220724125515855" style="zoom:80%;" />

<p>在每个子模块里配置号端口，启动：</p>
<img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/image-20220724125639643.png" alt="image-20220724125639643" style="zoom:67%;" />

<p>一个完整项目的就拆分成了多个微服务，不同微服务之间是独立进行开发和部署的。</p>
<p>稍微定义一下用户查询相关的业务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="type">int</span> uid;</span><br><span class="line">    String name;</span><br><span class="line">    String sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from DB_USER where uid = #&#123;uid&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">getUserById</span><span class="params">(<span class="type">int</span> uid)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    User <span class="title function_">getUserById</span><span class="params">(<span class="type">int</span> uid)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    UserMapper mapper;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(<span class="type">int</span> uid)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mapper.getUserById(uid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    UserService service;</span><br><span class="line">    <span class="comment">//这里以RESTFul风格为例</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/user/&#123;uid&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;uid&quot;)</span> <span class="type">int</span> uid)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> service.getUserById(uid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图书查询业务，在图书管理微服务中（别忘了导入Mybatis依赖以及配置数据源）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="type">int</span> bid;</span><br><span class="line">    String title;</span><br><span class="line">    String desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from DB_BOOK where bid = #&#123;bid&#125;&quot;)</span></span><br><span class="line">    Book <span class="title function_">getBookById</span><span class="params">(<span class="type">int</span> bid)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    Book <span class="title function_">getBookById</span><span class="params">(<span class="type">int</span> bid)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    BookMapper mapper;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getBookById</span><span class="params">(<span class="type">int</span> bid)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mapper.getBookById(bid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    BookService service;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/book/&#123;bid&#125;&quot;)</span></span><br><span class="line">    Book <span class="title function_">findBookById</span><span class="params">(<span class="meta">@PathVariable(&quot;bid&quot;)</span> <span class="type">int</span> bid)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> service.getBookById(bid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面业务相关的依赖：使用Mybatis，首先在父项目中添加MySQL驱动和Lombok依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>由于不是所有的子项目都需要用到Mybatis，我们在父项目中只进行<strong>版本管理</strong>（dependencyManagement）即可：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接着我们就可以在用户服务子项目中添加此依赖了：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="服务间调用"><a href="#服务间调用" class="headerlink" title="服务间调用"></a>服务间调用</h4><p>前面完成了用户信息查询和图书信息查询，现在来完成借阅服务。</p>
<p>借阅服务是一个关联性比较强的服务，它不仅仅需要查询借阅信息，同时可能还需要获取借阅信息下的详细信息，比如具体那个用户借阅了哪本书，并且用户和书籍的详情也需要同时出现，那么这种情况下，我们就需要去访问除了借阅表以外的用户表和图书表。</p>
<p>但是这显然是违反我们之前所说的单一职责的，相同的业务功能不应该重复出现，但是现在由需要在此服务中查询用户的信息和图书信息，那怎么办呢？我们可以让一个服务去通过HTTP调用另一个服务来获取信息。</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24egy1h0js4et40uj21q20agq52.jpg" alt="image-20220323140322502"></p>
<p>这样，图书管理微服务和用户管理微服务相对于借阅记录，就形成了一个生产者和消费者的关系，前者是生产者，后者便是消费者。</p>
<p>但是有个问题，实体类User和Book实体实际上是在另外两个微服务中定义的，相当于当前项目并没有定义这些实体类。一般是将所有服务需要用到的实体类单独放入另一个一个项目中，然后让这些项目引用集中存放实体类的那个项目，这样就可以保证每个微服务的实体类信息都可以共用了：</p>
<img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/image-20220724131345544.png" alt="image-20220724131345544" style="zoom: 67%;" />

<p>然后只需要在对应的类中引用此项目作为依赖即可：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>进行服务远程调用我们需要用到<code>RestTemplate</code>：简易示例（查询某个用户借了什么书）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BorrowServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BorrowService</span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    BorrowMapper mapper;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserBorrowDetail <span class="title function_">getUserBorrowDetailByUid</span><span class="params">(<span class="type">int</span> uid)</span> &#123;</span><br><span class="line">        List&lt;Borrow&gt; borrow = mapper.getBorrowsByUid(uid);</span><br><span class="line">        <span class="comment">//RestTemplate支持多种方式的远程调用</span></span><br><span class="line">        <span class="type">RestTemplate</span> <span class="variable">template</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">        <span class="comment">//这里通过调用getForObject来请求其他服务，并将结果自动进行封装</span></span><br><span class="line">        <span class="comment">//获取User信息</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> template.getForObject(<span class="string">&quot;http://localhost:8101/user/&quot;</span>+uid, User.class);</span><br><span class="line">        <span class="comment">//获取每一本书的详细信息</span></span><br><span class="line">        List&lt;Book&gt; bookList = borrow</span><br><span class="line">                .stream()</span><br><span class="line">                .map(b -&gt; template.getForObject(<span class="string">&quot;http://localhost:8201/book/&quot;</span>+b.getBid(), Book.class))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserBorrowDetail</span>(user, bookList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h4><p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24egy1h0jthur4u0j21lu0dytam.jpg" alt="image-20220323145051821"></p>
<p><strong>Eureka能够自动注册并发现微服务，然后对服务的状态、信息进行集中管理，这样当我们需要获取其他服务的信息时，我们只需要向Eureka进行查询即可</strong>。</p>
<p>那么现在来搭建一个Eureka服务器，只需要创建一个新的Maven项目即可，然后我们需要在父工程中添加一下SpringCloud的依赖，这里选用<code>2021.0.1</code>版本（Spring Cloud 最新的版本命名方式变更了，现在是 <em><strong>YEAR.x</strong></em> 这种命名方式，具体可以在官网查看：<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-cloud#learn%EF%BC%89%EF%BC%9A">https://spring.io/projects/spring-cloud#learn）：</a></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2021.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接着我们为新创建的项目添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下载内容有点多，首次导入请耐心等待一下。</p>
<p>接着我们来创建主类，还是一样的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaServer</span>  <span class="comment">//一定要加这个注解</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaServerApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(EurekaServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着需要修改一下配置文件（可能要删掉注释）：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8888</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="comment"># 开启之前需要修改一下客户端设置（虽然是服务端</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">  	<span class="comment"># 由于我们是作为服务端角色，所以不需要获取服务端，改为false，默认为true</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 暂时不需要将自己也注册到Eureka</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 将eureka服务端指向自己</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8888/eureka</span></span><br></pre></td></tr></table></figure>

<p>启动完成后，直接输入地址+端口即可访问Eureka的管理后台：<a target="_blank" rel="noopener" href="http://localhost:8888/">http://localhost:8888/</a></p>
<p>可以看到目前还没有任何的服务注册到Eureka，我们接着来配置一下我们的三个微服务，首先还是需要导入Eureka依赖（注意别导错了，名称里面有个starter的才是）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后修改配置文件：（上面的port是每个微服务不一样的，这里注意层级，不要让eureka和port对齐了！）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8101</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">borrow-service</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8888/eureka</span></span><br></pre></td></tr></table></figure>

<p>启动，然后打开Eureka的服务管理页面，可以看到我们刚刚开启的服务：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/image-20220724181306012.png" alt="image-20220724181306012"></p>
<p>当服务启动之后，会每隔一段时间给Eureka发送一次心跳包，这样Eureka就能够感知到该服务是否处于正常运行状态。</p>
<p><strong>那么，现在我们怎么实现服务发现呢？</strong></p>
<p>也就是说，我们之前如果需要对其他微服务进行远程调用，那么就必须要知道其他服务的地址：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> template.getForObject(<span class="string">&quot;http://localhost:8082/user/&quot;</span>+uid, User.class);</span><br></pre></td></tr></table></figure>

<p>而现在有了Eureka之后，我们可以直接向其进行查询，得到对应的微服务地址，这里直接将服务名称替换即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BorrowServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BorrowService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    BorrowMapper mapper;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    RestTemplate template;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserBorrowDetail <span class="title function_">getUserBorrowDetailByUid</span><span class="params">(<span class="type">int</span> uid)</span> &#123;</span><br><span class="line">        List&lt;Borrow&gt; borrow = mapper.getBorrowsByUid(uid);</span><br><span class="line">        <span class="comment">//这里不用再写IP，直接写配置文件的服务名称user-service</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> template.getForObject(<span class="string">&quot;http://user-service/user/&quot;</span>+uid, User.class);</span><br><span class="line">        <span class="comment">//这里不用再写IP，直接写服务名称book-service</span></span><br><span class="line">        List&lt;Book&gt; bookList = borrow</span><br><span class="line">                .stream()</span><br><span class="line">                .map(b -&gt; template.getForObject(<span class="string">&quot;http://book-service/book/&quot;</span>+b.getBid(), Book.class))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserBorrowDetail</span>(user, bookList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们手动将RestTemplate声明为一个Bean，然后添加<code>@LoadBalanced</code>注解，这样Eureka就会对服务的调用进行自动发现，并提供负载均衡：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    RestTemplate <span class="title function_">template</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>负载均衡的说明：</p>
<p>同一个服务器实际上是可以注册很多个的，但是要端口不同，比如这里创建多个用户查询服务，我们现在将原有的端口配置修改一下，由IDEA中设定启动参数来决定，这样就可以多创建几个不同端口的启动项了：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/image-20220724184502403.png" alt="image-20220724184502403"></p>
<img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/image-20220724184849728.png" alt="image-20220724184849728" style="zoom:67%;" />

<p>可以在controller打印一些日志进行测试，可以看到，两个实例能够均匀地被分配请求。</p>
<p>这样，服务自动发现以及简单的负载均衡就实现完成了，并且，如果某个微服务挂掉了，只要存在其他同样的微服务实例在运行，那么就不会导致整个微服务不可用，极大地保证了安全性。</p>
<h4 id="注册中心高可用"><a href="#注册中心高可用" class="headerlink" title="注册中心高可用"></a>注册中心高可用</h4><p>各位可否想过这样的一个问题？虽然Eureka能够实现服务注册和发现，但是如果Eureka服务器崩溃了，岂不是所有需要用到服务发现的微服务就GG了？</p>
<p>为了避免，这种问题，我们也可以像上面那样，搭建Eureka集群，存在多个Eureka服务器，这样就算挂掉其中一个，其他的也还在正常运行，就不会使得服务注册与发现不可用。当然，要是物理黑客直接炸了整个机房，那还是算了吧。</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0k41ady28j21jy0iwmzt.jpg" alt="image-20220323205531185"></p>
<p>我们来看看如何搭建Eureka集群，这里由于机器配置不高，就搭建两个Eureka服务器组成集群。</p>
<p>首先我们需要修改一下Eureka服务端的配置文件，这里我们创建两个配置文件，：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8801</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eurekaserver</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">  	<span class="comment"># 由于不支持多个localhost的Eureka服务器，但是又只有本地测试环境，所以就只能自定义主机名称了</span></span><br><span class="line">  	<span class="comment"># 主机名称改为eureka01</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka01</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 去掉register-with-eureka选项，让Eureka服务器自己注册到其他Eureka服务器，这样才能相互启用</span></span><br><span class="line">    <span class="comment"># register-with-eureka: false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">    	<span class="comment"># 注意这里填写其他Eureka服务器的地址，不用写自己的</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka01:8801/eureka</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8802</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eurekaserver</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka02</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka01:8801/eureka</span></span><br></pre></td></tr></table></figure>

<p>这里由于我们修改成自定义的地址，需要在hosts文件中将其解析到172.0.0.1才能回到localhost，Linux/Mac下文件路径为<code>/etc/hosts</code>，Windows下为<code>C:\Windows\system32\drivers\etc\hosts</code>：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0k48bkgyoj212q07a0te.jpg" alt="image-20220323210218653"></p>
<p>对创建的两个配置文件分别添加启动配置，直接使用<code>spring.profiles.active</code>指定启用的配置文件即可：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0k4u09lpxj22aw0py0y5.jpg" alt="image-20220323212308857"></p>
<p>接着启动这两个注册中心，这两个Eureka管理页面都可以被访问，我们访问其中一个：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0k4fxnlxtj21yk0cytao.jpg" alt="image-20220323210937341"></p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0k4chvjv8j21rq07it9k.jpg" alt="image-20220323210619533"></p>
<p>可以看到下方<code>replicas</code>中已经包含了另一个Eureka服务器的地址，并且是可用状态。</p>
<p>接着需要把 微服务配置 修改：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">    	<span class="comment"># 将两个Eureka的地址都加入，这样就算有一个Eureka挂掉，也能完成注册</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8801/eureka,</span> <span class="string">http://localhost:8802/eureka</span></span><br></pre></td></tr></table></figure>

<p>可以看到，服务全部成功注册，并且两个Eureka服务端都显示为已注册：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0k4gvpxdtj21vc0dm41j.jpg" alt="image-20220323211032311"></p>
<p>接着我们模拟一下，将其中一个Eureka服务器关闭掉，可以看到它会直接变成不可用状态：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0k4ke207fj21rm06w75k.jpg" alt="image-20220323211354516"></p>
<p>当然，如果这个时候我们重启刚刚关闭的Eureka服务器，会自动同步其他Eureka服务器的数据。</p>
<hr>
<h3 id="（3）LoadBalancer-负载均衡"><a href="#（3）LoadBalancer-负载均衡" class="headerlink" title="（3）LoadBalancer 负载均衡"></a>（3）LoadBalancer 负载均衡</h3><p>在2020年前的SpringCloud版本是采用Ribbon作为负载均衡实现，但是2020年的版本之后SpringCloud把Ribbon移除了，进而用自己编写的LoadBalancer替代。</p>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>添加<code>@LoadBalanced</code>注解之后，会启用拦截器对服务调用请求进行拦截（注意这里是针对发起的请求进行拦截），叫做<code>LoadBalancerInterceptor</code>，它实现<code>ClientHttpRequestInterceptor</code>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ClientHttpRequestInterceptor</span> &#123;</span><br><span class="line">    ClientHttpResponse <span class="title function_">intercept</span><span class="params">(HttpRequest request, <span class="type">byte</span>[] body, ClientHttpRequestExecution execution)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要是对<code>intercept</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ClientHttpResponse <span class="title function_">intercept</span><span class="params">(<span class="keyword">final</span> HttpRequest request, <span class="keyword">final</span> <span class="type">byte</span>[] body, <span class="keyword">final</span> ClientHttpRequestExecution execution)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">URI</span> <span class="variable">originalUri</span> <span class="operator">=</span> request.getURI();</span><br><span class="line">    <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> originalUri.getHost();</span><br><span class="line">    Assert.state(serviceName != <span class="literal">null</span>, <span class="string">&quot;Request URI does not contain a valid hostname: &quot;</span> + originalUri);</span><br><span class="line">    <span class="keyword">return</span> (ClientHttpResponse)<span class="built_in">this</span>.loadBalancer.execute(serviceName, <span class="built_in">this</span>.requestFactory.createRequest(request, body, execution));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端会在发起请求时执行这些拦截器。</p>
<p>那么这个拦截器做了什么事情呢，首先我们要明确，我们给过来的请求地址，并不是一个有效的主机名称，而是服务名称，那么怎么才能得到真正需要访问的主机名称呢，肯定是得找Eureka获取的。</p>
<p>我们来看看<code>loadBalancer.execute()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从上面给进来了服务的名称和具体的请求实体</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">execute</span><span class="params">(String serviceId, LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">hint</span> <span class="operator">=</span> <span class="built_in">this</span>.getHint(serviceId);</span><br><span class="line">    LoadBalancerRequestAdapter&lt;T, DefaultRequestContext&gt; lbRequest = <span class="keyword">new</span> <span class="title class_">LoadBalancerRequestAdapter</span>(request, <span class="keyword">new</span> <span class="title class_">DefaultRequestContext</span>(request, hint));</span><br><span class="line">    Set&lt;LoadBalancerLifecycle&gt; supportedLifecycleProcessors = <span class="built_in">this</span>.getSupportedLifecycleProcessors(serviceId);</span><br><span class="line">    supportedLifecycleProcessors.forEach((lifecycle) -&gt; &#123;</span><br><span class="line">        lifecycle.onStart(lbRequest);</span><br><span class="line">    &#125;);</span><br><span class="line">  	<span class="comment">//可以看到在这里会调用choose方法自动获取对应的服务实例信息</span></span><br><span class="line">    <span class="type">ServiceInstance</span> <span class="variable">serviceInstance</span> <span class="operator">=</span> <span class="built_in">this</span>.choose(serviceId, lbRequest);</span><br><span class="line">    <span class="keyword">if</span> (serviceInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">        supportedLifecycleProcessors.forEach((lifecycle) -&gt; &#123;</span><br><span class="line">            lifecycle.onComplete(<span class="keyword">new</span> <span class="title class_">CompletionContext</span>(Status.DISCARD, lbRequest, <span class="keyword">new</span> <span class="title class_">EmptyResponse</span>()));</span><br><span class="line">        &#125;);</span><br><span class="line">      	<span class="comment">//没有发现任何此服务的实例就抛异常（之前的测试中可能已经遇到了）</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No instances available for &quot;</span> + serviceId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">//成功获取到对应服务的实例，这时就可以发起HTTP请求获取信息了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.execute(serviceId, serviceInstance, lbRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实际上在进行负载均衡的时候，会向Eureka发起请求，选择一个可用的对应服务，然后会返回此服务的主机地址等信息。</strong></p>
<h4 id="自定义负载均衡策略"><a href="#自定义负载均衡策略" class="headerlink" title="自定义负载均衡策略"></a>自定义负载均衡策略</h4><p>LoadBalancer默认提供了两种负载均衡策略：</p>
<ul>
<li>RandomLoadBalancer  -  随机分配策略</li>
<li><strong>(默认)</strong> RoundRobinLoadBalancer  -  轮询分配策略</li>
</ul>
<p>现在我们希望修改默认的负载均衡策略，可以进行指定，比如我们现在希望<strong>用户服务</strong>采用随机分配策略，我们需要先创建随机分配策略的配置类（不用加<code>@Configuration</code>）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoadBalancerConfig</span> &#123;</span><br><span class="line">  	<span class="comment">//将官方提供的 RandomLoadBalancer 注册为Bean</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ReactorLoadBalancer&lt;ServiceInstance&gt; <span class="title function_">randomLoadBalancer</span><span class="params">(Environment environment, LoadBalancerClientFactory loadBalancerClientFactory)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomLoadBalancer</span>(loadBalancerClientFactory.getLazyProvider(name, ServiceInstanceListSupplier.class), name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们需要为对应的服务指定负载均衡策略，直接使用注解即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@LoadBalancerClient(value = &quot;userservice&quot;,      //指定为 userservice 服务，只要是调用此服务都会使用我们指定的策略</span></span><br><span class="line"><span class="meta">                    configuration = LoadBalancerConfig.class)</span>   <span class="comment">//指定我们刚刚定义好的配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    RestTemplate <span class="title function_">template</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们在<code>BlockingLoadBalancerClient</code>中添加断点，观察是否采用我们指定的策略进行请求：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0lc17or9aj221y07swhq.jpg" alt="image-20220324221750289"></p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0lc0mbsmqj21ye07yjuh.jpg" alt="image-20220324221713964"></p>
<p>发现访问userservice服务的策略已经更改为我们指定的策略了。</p>
<h4 id="OpenFeign实现负载均衡"><a href="#OpenFeign实现负载均衡" class="headerlink" title="OpenFeign实现负载均衡"></a>OpenFeign实现负载均衡</h4><p>官方文档：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-cloud-openfeign/docs/current/reference/html/">https://docs.spring.io/spring-cloud-openfeign/docs/current/reference/html/</a></p>
<p>Feign和RestTemplate一样，也是HTTP客户端请求工具，但是它的使用方式更加便捷。首先是依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接着在启动类添加<code>@EnableFeignClients</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BorrowApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(BorrowApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么现在我们需要调用其他微服务提供的接口，该怎么做呢？我们直接创建一个对应服务的接口类即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;userservice&quot;)</span>   <span class="comment">//声明为userservice服务的HTTP请求客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们直接创建所需类型的方法，比如我们之前的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RestTemplate</span> <span class="variable">template</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> template.getForObject(<span class="string">&quot;http://userservice/user/&quot;</span>+uid, User.class);</span><br></pre></td></tr></table></figure>

<p><strong>现在可以直接写成这样</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;userservice&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> &#123;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//路径保证和其他微服务提供的一致即可</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/user/&#123;uid&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">getUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;uid&quot;)</span> <span class="type">int</span> uid)</span>;  <span class="comment">//参数和返回值也保持一致</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们直接<strong>注入使用</strong>（有Mybatis那味了）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">UserClient userClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> UserBorrowDetail <span class="title function_">getUserBorrowDetailByUid</span><span class="params">(<span class="type">int</span> uid)</span> &#123;</span><br><span class="line">    List&lt;Borrow&gt; borrow = mapper.getBorrowsByUid(uid);</span><br><span class="line">    </span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userClient.getUserById(uid);  <span class="comment">//这里直接使用注入的bean，调用其接口方法</span></span><br><span class="line">    <span class="comment">//这里不用再写IP，直接写服务名称bookservice</span></span><br><span class="line">    List&lt;Book&gt; bookList = borrow</span><br><span class="line">            .stream()</span><br><span class="line">            .map(b -&gt; template.getForObject(<span class="string">&quot;http://bookservice/book/&quot;</span>+b.getBid(), Book.class))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserBorrowDetail</span>(user, bookList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问，可以看到结果依然是正确的：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0l51tto72j229e080dhe.jpg" alt="image-20220324181614387"></p>
<p>并且我们可以观察一下两个用户微服务的调用情况，也是以负载均衡的形式进行的。</p>
<p>按照同样的方法，我们接着将图书管理服务的调用也改成接口形式：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0l53boxmlj21j60bgq51.jpg" alt="image-20220324181740566"></p>
<p>最后我们的Service代码就变成了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BorrowServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BorrowService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    BorrowMapper mapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    UserClient userClient;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    BookClient bookClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserBorrowDetail <span class="title function_">getUserBorrowDetailByUid</span><span class="params">(<span class="type">int</span> uid)</span> &#123;</span><br><span class="line">        List&lt;Borrow&gt; borrow = mapper.getBorrowsByUid(uid);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userClient.getUserById(uid);</span><br><span class="line">        List&lt;Book&gt; bookList = borrow</span><br><span class="line">                .stream()</span><br><span class="line">                .map(b -&gt; bookClient.getBookById(b.getBid()))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserBorrowDetail</span>(user, bookList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="（4）Hystrix-服务熔断"><a href="#（4）Hystrix-服务熔断" class="headerlink" title="（4）Hystrix 服务熔断"></a>（4）Hystrix 服务熔断</h3><p>官方文档：<a target="_blank" rel="noopener" href="https://cloud.spring.io/spring-cloud-static/spring-cloud-netflix/1.3.5.RELEASE/single/spring-cloud-netflix.html#_circuit_breaker_hystrix_clients">https://cloud.spring.io/spring-cloud-static/spring-cloud-netflix/1.3.5.RELEASE/single/spring-cloud-netflix.html#_circuit_breaker_hystrix_clients</a></p>
<p>我们知道，微服务之间是可以进行相互调用的，那么如果出现了下面的情况会导致什么问题？</p>
<p>由于位于最底端的服务提供者E发生故障，那么此时会直接导致服务ABCD全线崩溃。</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0ky50sw4jj219s07yabg.jpg" alt="image-20220324141706946"></p>
<p>这种问题实际上是不可避免的，由于多种因素，比如网络卡顿、系统故障、硬件问题等，都存在一定可能，会导致这种极端的情况发生。因此，我们需要寻找一个应对这种极端情况的解决方案。</p>
<p>为了解决分布式系统的雪崩问题，SpringCloud提供了Hystrix熔断器组件，我们来详细看看它的工作机制。</p>
<h4 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h4><p>首先我们来看看服务降级，注意一定要区分开服务降级和服务熔断的区别，服务降级并不会直接返回错误，而是可以提供一个补救措施，正常响应给请求者。这样相当于服务依然可用，但是服务能力肯定是下降了的。</p>
<p>我们就基于借阅管理服务来进行讲解，我们不开启用户服务和图书服务，表示用户服务和图书服务已经挂掉了。</p>
<p>这里我们导入Hystrix的依赖（此项目已经停止维护，SpringCloud依赖中已经不自带了，所以说需要自己单独导入）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  		<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接着我们需要在启动类添加（@EnableHystrix）注解开启：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableHystrix</span>   <span class="comment">//启用Hystrix</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BorrowApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(BorrowApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么现在，由于用户服务和图书服务不可用，所以查询借阅信息的请求肯定是没办法正常响应的，这时我们可以提供一个备选方案，也就是说当服务出现异常时，返回我们的备选方案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BorrowController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    BorrowService service;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;onError&quot;)</span>    <span class="comment">//使用@HystrixCommand来指定备选方案</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/borrow/&#123;uid&#125;&quot;)</span></span><br><span class="line">    UserBorrowDetail <span class="title function_">findUserBorrows</span><span class="params">(<span class="meta">@PathVariable(&quot;uid&quot;)</span> <span class="type">int</span> uid)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> service.getUserBorrowDetailByUid(uid);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//备选方案，这里直接返回空列表了</span></span><br><span class="line">  	<span class="comment">//注意参数和返回值要和上面本来的方法一致</span></span><br><span class="line">    UserBorrowDetail <span class="title function_">onError</span><span class="params">(<span class="type">int</span> uid)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserBorrowDetail</span>(<span class="literal">null</span>, Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，虽然我们的服务无法正常运行了，但是依然可以给浏览器正常返回响应数据：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0kzgnuv0ej21x406ujvb.jpg" alt="image-20220324150253610"></p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0kzgygdd3j218s06qjru.jpg" alt="image-20220324150310955"></p>
<p>服务降级是一种比较温柔的解决方案，虽然服务本身的不可用，但是能够保证正常响应数据。</p>
<h4 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h4><p>熔断机制是应对雪崩效应的一种微服务链路保护机制，当检测出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回”错误”的响应信息。当检测到该节点微服务响应正常后恢复调用链路。</p>
<p>实际上，<strong>在一段时间内多次调用失败，服务降级会升级为服务熔断。</strong></p>
<p>我们可以添加两条输出语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BorrowController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    BorrowService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;onError&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/borrow/&#123;uid&#125;&quot;)</span></span><br><span class="line">    UserBorrowDetail <span class="title function_">findUserBorrows</span><span class="params">(<span class="meta">@PathVariable(&quot;uid&quot;)</span> <span class="type">int</span> uid)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始向其他服务获取信息&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> service.getUserBorrowDetailByUid(uid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UserBorrowDetail <span class="title function_">onError</span><span class="params">(<span class="type">int</span> uid)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务错误，进入备选方法！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserBorrowDetail</span>(<span class="literal">null</span>, Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，我们在浏览器中疯狂点击刷新按钮，对此服务疯狂发起请求，可以看到后台：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0kzz87azgj21960hwwhz.jpg" alt="image-20220324152044551"></p>
<p>一开始的时候，会正常地去调用Controller对应的方法<code>findUserBorrows</code>，发现失败然后进入备选方法，但是我们发现在持续请求一段时间之后，没有再调用这个方法，而是直接调用备选方案，这便是升级到了熔断状态。</p>
<p>我们可以继续不断点击，继续不断地发起请求：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0l06mgm5yj21uy0b0gns.jpg" alt="image-20220324152750797"></p>
<p>可以看到，过了一段时间之后，会尝试正常执行一次<code>findUserBorrows</code>，但是依然是失败状态，所以继续保持熔断状态。</p>
<p>所以得到结论，它能够对一段时间内出现的错误进行侦测，当侦测到出错次数过多时，熔断器会打开，所有的请求会直接响应失败，一段时间后，只执行一定数量的请求，如果还是出现错误，那么则继续保持打开状态，否则说明服务恢复正常运行，关闭熔断器。</p>
<p>我们可以测试一下，开启关闭的两个服务后，继续点击：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0l09mmg95j21ue0eatb5.jpg" alt="image-20220324153044583"></p>
<p>可以看到，当另外两个服务正常运行之后，当再次尝试调用<code>findUserBorrows</code>之后会成功，于是熔断机制就关闭了，服务恢复运行。</p>
<p>总结一下：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0l0iulmatj21rc0ba0vj.jpg" alt="image-20220324153935858"></p>
<h4 id="OpenFeign实现降级"><a href="#OpenFeign实现降级" class="headerlink" title="OpenFeign实现降级"></a>OpenFeign实现降级</h4><p>Hystrix也可以配合Feign进行降级，我们可以对应接口中定义的远程调用单独进行降级操作。</p>
<p>比如我们还是以用户服务挂掉为例，那么这个时候肯定是会远程调用失败的，也就是说我们的Controller中的方法在执行过程中会直接抛出异常，进而被Hystrix监控到并进行服务降级。</p>
<p>而实际上导致方法执行异常的根源就是远程调用失败，所以我们换个思路，既然用户服务调用失败，那么我就给这个远程调用添加一个替代方案，如果此远程调用失败，那么就直接上替代方案。那么怎么实现替代方案呢？我们知道Feign都是以接口的形式来声明远程调用，那么既然远程调用已经失效，我们就自行对其进行实现，创建一个实现类，对原有的接口方法进行替代方案实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>   <span class="comment">//注意，需要将其注册为Bean，Feign才能自动注入</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserFallbackClient</span> <span class="keyword">implements</span> <span class="title class_">UserClient</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(<span class="type">int</span> uid)</span> &#123;   <span class="comment">//这里我们自行对其进行实现，并返回我们的替代方案</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;我是替代方案&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们只需要在原有的接口中 @FeignClient注解属性fallback 指定失败替代的实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fallback参数指定为我们刚刚编写的实现类</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;userservice&quot;, fallback = UserFallbackClient.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/user/&#123;uid&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">getUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;uid&quot;)</span> <span class="type">int</span> uid)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在去掉<code>BorrowController</code>的<code>@HystrixCommand</code>注解和备选方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BorrowController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    BorrowService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/borrow/&#123;uid&#125;&quot;)</span></span><br><span class="line">    UserBorrowDetail <span class="title function_">findUserBorrows</span><span class="params">(<span class="meta">@PathVariable(&quot;uid&quot;)</span> <span class="type">int</span> uid)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> service.getUserBorrowDetailByUid(uid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们在配置文件中开启feign熔断支持：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">circuitbreaker:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>启动服务，调用接口试试看：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0m0k7jve9j21zq03kdi6.jpg" alt="image-20220325122629016"></p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0m0gmj8ayj229c07q75v.jpg" alt="image-20220325122301779"></p>
<p>可以看到，现在已经采用我们的替代方案作为结果。</p>
<h4 id="Actuator监控页面部署"><a href="#Actuator监控页面部署" class="headerlink" title="Actuator监控页面部署"></a>Actuator监控页面部署</h4><p>除了对服务的降级和熔断处理，我们也可以对其进行实时监控，只需要安装监控页面即可，这里我们创建一个新的项目模块，导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接着添加配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8900</span></span><br><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">dashboard:</span></span><br><span class="line">    <span class="comment"># 将localhost添加到白名单，默认是不允许的</span></span><br><span class="line">    <span class="attr">proxy-stream-allow-list:</span> <span class="string">&quot;localhost&quot;</span></span><br></pre></td></tr></table></figure>

<p>接着创建主类，注意需要添加<code>@EnableHystrixDashboard</code>注解开启管理页面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HystrixDashBoardApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(HystrixDashBoardApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动Hystrix管理页面服务，然后我们需要在要进行监控的服务中添加Actuator依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Actuator是SpringBoot程序的监控系统，可以实现健康检查，记录信息等。需要引入spring-boot-starter-actuator，并做简单的配置即可。</p>
</blockquote>
<p>添加此依赖后，我们可以在IDEA中查看运行情况：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0ld5ia0z8j21uw0e6god.jpg" alt="image-20220324225633805"></p>
<p>然后在配置文件中配置Actuator添加暴露：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure>

<p>接着我们打开刚刚启动的管理页面，地址为：<a target="_blank" rel="noopener" href="http://localhost:8900/hystrix/">http://localhost:8900/hystrix/</a></p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0ld6jtiijj22ij0u042v.jpg" alt="image-20220324225733550"></p>
<p>在中间填写要监控的服务：比如借阅服务：<a target="_blank" rel="noopener" href="http://localhost:8301/actuator/hystrix.stream%EF%BC%8C%E6%B3%A8%E6%84%8F%E5%90%8E%E9%9D%A2%E8%A6%81%E6%B7%BB%E5%8A%A0%60/actuator/hystrix.stream%60%EF%BC%8C%E7%84%B6%E5%90%8E%E7%82%B9%E5%87%BBMonitor">http://localhost:8301/actuator/hystrix.stream，注意后面要添加`/actuator/hystrix.stream`，然后点击Monitor</a> Stream即可进入监控页面：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0ldejq3n0j22ly0puwhu.jpg" alt="image-20220324230515009"></p>
<p>可以看到现在都是Loading状态，这是因为还没有开始统计，我们现在尝试调用几次我们的服务：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0ldfbaoi5j22660bqgnc.jpg" alt="image-20220324230559068"></p>
<p>可以看到，在调用之后，监控页面出现了信息：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0ldgfihczj21wq0ksn03.jpg" alt="image-20220324230703600"></p>
<p>可以看到5次访问都是正常的，所以显示为绿色，接着我们来尝试将图书服务关闭，这样就会导致服务降级甚至熔断，然后再多次访问此服务看看监控会如何变化：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0ldiuq9naj222a0l2whx.jpg" alt="image-20220324230923472"></p>
<p>可以看到，错误率直接飙升到100%，并且一段时间内持续出现错误，中心的圆圈也变成了红色，我们继续进行访问：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0ldjvo0ppj21j20iy0v3.jpg" alt="image-20220324231022133"></p>
<p>在出现大量错误的情况下保持持续访问，可以看到此时已经将服务熔断，<code>Circuit</code>更改为Open状态，并且图中的圆圈也变得更大，表示压力在持续上升。</p>
<hr>
<h3 id="（5）Gateway-路由网关"><a href="#（5）Gateway-路由网关" class="headerlink" title="（5）Gateway 路由网关"></a>（5）Gateway 路由网关</h3><p>官网地址：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/</a></p>
<p>我们知道，如果我们需要连接互联网，那么就需要将手机或是电脑连接到家里的路由器才可以，而路由器则连接光猫，光猫再通过光纤连接到互联网，也就是说，互联网方向发送过来的数据，需要经过路由器才能到达我们的设备。而路由器充当的就是数据包中转站，所有的局域网设备都无法直接与互联网连接，而是需要经过路由器进行中转，我们一般说路由器下的网络是内网，而互联网那一端是外网。</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0l2ejn70ej21di0b4wfr.jpg" alt="image-20220324164439809"></p>
<p>我们的局域网设备，无法被互联网上的其他设备直接访问，肯定是能够保证到安全性的。并互联网发送过来的数据，需要经过路由器进行解析，识别到底是哪一个设备的数据包，然后再发送给对应的设备。</p>
<p>而我们的微服务也是这样，一般情况下，可能并不是所有的微服务都需要直接暴露给外部调用，这时我们就可以使用路由机制，添加一层防护，让所有的请求全部通过路由来转发到各个微服务，并且转发给多个相同微服务实例也可以实现负载均衡。</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0m1kz3kycj21iq0huwhb.jpg" alt="image-20220325130147758"></p>
<p>在之前，路由的实现一般使用<strong>Zuul</strong>，但是已经停更，而现在新出现了由SpringCloud官方开发的<strong>Gateway</strong>路由，它相比Zuul不仅性能上得到了一定的提升，并且是官方推出，契合性也会更好，所以我们这里就主要讲解Gateway。</p>
<h4 id="部署网关"><a href="#部署网关" class="headerlink" title="部署网关"></a>部署网关</h4><p>现在我们来创建一个新的项目作为网关，这里需要添加两个依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第一个依赖就是网关的依赖，而第二个则跟其他微服务一样，需要注册到Eureka才能生效，注意别添加Web依赖，使用的是WebFlux框架。</p>
<p>然后我们来完善一下配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8500</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8801/eureka,</span> <span class="string">http://localhost:8802/eureka</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br></pre></td></tr></table></figure>

<p>现在就可以启动了：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0l34rlri8j22dw0b80ve.jpg" alt="image-20220324170951878"></p>
<p>但是现在还没有配置任何的路由功能，我们接着将路由功能进行配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">    	<span class="comment"># 配置路由，注意这里是个列表，每一项都包含了很多信息</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">borrow-service</span>   <span class="comment"># 路由名称</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://borrowservice</span>  <span class="comment"># 路由的地址，lb表示使用负载均衡到微服务，也可以使用http正常转发</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment"># 路由规则，断言什么请求会被路由</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/borrow/**</span>  <span class="comment"># 只要是访问的这个路径，一律都被路由到上面指定的服务</span></span><br></pre></td></tr></table></figure>

<p>路由规则的详细列表（断言工厂列表）在这里：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%8C%87%E5%AE%9A%E5%A4%9A%E7%A7%8D%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%8C%85%E6%8B%AC%E6%8C%87%E5%AE%9A%E6%97%B6%E9%97%B4%E6%AE%B5%E3%80%81Cookie%E6%90%BA%E5%B8%A6%E6%83%85%E5%86%B5%E3%80%81Header%E6%90%BA%E5%B8%A6%E6%83%85%E5%86%B5%E3%80%81%E8%AE%BF%E9%97%AE%E7%9A%84%E5%9F%9F%E5%90%8D%E5%9C%B0%E5%9D%80%E3%80%81%E8%AE%BF%E9%97%AE%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%81%E8%B7%AF%E5%BE%84%E3%80%81%E5%8F%82%E6%95%B0%E3%80%81%E8%AE%BF%E9%97%AE%E8%80%85IP%E7%AD%89%E3%80%82%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE%E7%B1%BB%E8%BF%9B%E8%A1%8C%E9%85%8D%E7%BD%AE%EF%BC%8C%E4%BD%86%E6%98%AF%E8%BF%98%E6%98%AF%E6%8E%A8%E8%8D%90%E7%9B%B4%E6%8E%A5%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%8C%E7%9C%81%E4%BA%8B%E3%80%82">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories，可以指定多种类型，包括指定时间段、Cookie携带情况、Header携带情况、访问的域名地址、访问的方法、路径、参数、访问者IP等。也可以使用配置类进行配置，但是还是推荐直接配置文件，省事。</a></p>
<p>接着启动网关，搭载Arm架构芯片的Mac电脑可能会遇到这个问题：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0m59qpakvj21og074q5a.jpg" alt="image-20220325150924472"></p>
<p>这是因为没有找到适用于此架构的动态链接库，不影响使用，无视即可，希望以后的版本能修复吧。</p>
<p>可以看到，我们现在可以直接通过路由来访问我们的服务了：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0l3cme88qj226g0a6abq.jpg" alt="image-20220324171724493"></p>
<p>注意此时依然可以通过原有的服务地址进行访问：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0l3efx1npj225c070400.jpg" alt="image-20220324171909828"></p>
<p>这样我们就可以将不需要外网直接访问的微服务全部放到内网环境下，而只依靠网关来对外进行交涉。</p>
<h4 id="路由过滤器"><a href="#路由过滤器" class="headerlink" title="路由过滤器"></a>路由过滤器</h4><p>路由过滤器支持以某种方式修改传入的 HTTP 请求或传出的 HTTP 响应，路由过滤器的范围是某一个路由，跟之前的断言一样，Spring Cloud Gateway 也包含许多内置的路由过滤器工厂，详细列表：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories</a></p>
<p>比如我们现在希望在请求到达时，在请求头中添加一些信息再转发给我们的服务，那么这个时候就可以使用路由过滤器来完成，我们只需要对配置文件进行修改：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">borrow-service</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://borrowservice</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/borrow/**</span></span><br><span class="line">      <span class="comment"># 继续添加新的路由配置，这里就以书籍管理服务为例</span></span><br><span class="line">      <span class="comment"># 注意-要对齐routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">book-service</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://bookservice</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/book/**</span></span><br><span class="line">        <span class="attr">filters:</span>   <span class="comment"># 添加过滤器</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=Test,</span> <span class="string">HelloWorld!</span></span><br><span class="line">        <span class="comment"># AddRequestHeader 就是添加请求头信息，其他工厂请查阅官网</span></span><br></pre></td></tr></table></figure>

<p>接着我们在BookController中获取并输出一下，看看是不是成功添加了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    BookService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/book/&#123;bid&#125;&quot;)</span></span><br><span class="line">    Book <span class="title function_">findBookById</span><span class="params">(<span class="meta">@PathVariable(&quot;bid&quot;)</span> <span class="type">int</span> bid,</span></span><br><span class="line"><span class="params">                      HttpServletRequest request)</span>&#123;</span><br><span class="line">        System.out.println(request.getHeader(<span class="string">&quot;Test&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> service.getBookById(bid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们通过Gateway访问我们的图书管理服务：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0m57rm7t4j21bq07kt9c.jpg" alt="image-20220325150730814"></p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0m5cstkq3j21v403q0ud.jpg" alt="image-20220325151220776"></p>
<p>可以看到这里成功获取到由网关添加的请求头信息了。</p>
<p>除了针对于某一个路由配置过滤器之外，我们也可以自定义全局过滤器，它能够作用于全局。但是我们需要通过代码的方式进行编写，比如我们要实现拦截没有携带指定请求参数的请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>   <span class="comment">//需要注册为Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;   <span class="comment">//只需要实现此方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们编写判断：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">    <span class="comment">//先获取ServerHttpRequest对象，注意不是HttpServletRequest</span></span><br><span class="line">    <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">    <span class="comment">//打印一下所有的请求参数</span></span><br><span class="line">    System.out.println(request.getQueryParams());</span><br><span class="line">    <span class="comment">//判断是否包含test参数，且参数值为1</span></span><br><span class="line">    List&lt;String&gt; value = request.getQueryParams().get(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(value != <span class="literal">null</span> &amp;&amp; value.contains(<span class="string">&quot;1&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">//将ServerWebExchange向过滤链的下一级传递（跟JavaWeb中介绍的过滤器其实是差不多的）</span></span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//直接在这里不再向下传递，然后返回响应</span></span><br><span class="line">        <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到结果：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0m6ahb0zvj21ak07qaah.jpg" alt="image-20220325154443063"></p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0m6axjl3oj21ai072t9h.jpg" alt="image-20220325154508853"></p>
<p>成功实现规则判断和拦截操作。</p>
<p>当然，过滤器肯定是可以存在很多个的，所以我们可以手动指定过滤器之间的顺序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;   <span class="comment">//实现Ordered接口</span></span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>注意Order的值越小优先级越高，并且无论是在配置文件中编写的单个路由过滤器还是全局路由过滤器，都会受到Order值影响（单个路由的过滤器Order值按从上往下的顺序从1开始递增），最终是按照Order值决定哪个过滤器优先执行，当Order值一样时 全局路由过滤器执行 <code>优于</code> 单独的路由过滤器执行。</p>
<hr>
<h3 id="（6）Config-配置中心"><a href="#（6）Config-配置中心" class="headerlink" title="（6）Config 配置中心"></a>（6）Config 配置中心</h3><p><strong>官方文档：</strong><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-cloud-config/docs/current/reference/html/">https://docs.spring.io/spring-cloud-config/docs/current/reference/html/</a></p>
<p>经过前面的学习，我们对于一个分布式应用的技术选型和搭建已经了解得比较多了，但是各位有没有发现一个问题，如果我们的微服务项目需要部署很多个实例，那么配置文件我们岂不是得一个一个去改，可能十几个实例还好，要是有几十个上百个呢？那我们一个一个去配置，岂不直接猝死在工位上。</p>
<p>所以，我们需要一种更加高级的集中化地配置文件管理工具，集中地对配置文件进行配置。</p>
<blockquote>
<p>Spring Cloud Config 为分布式系统中的外部配置提供服务器端和客户端支持。使用 Config Server，您可以集中管理所有环境中应用程序的外部配置。</p>
</blockquote>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0m8zggbzyj21ha0csjt5.jpg" alt="image-20220325171754862"></p>
<p>实际上<strong>Spring Cloud Config</strong>就是一个配置中心，所有的服务都可以从配置中心取出配置，而配置中心又可以从GitHub远程仓库中获取云端的配置文件，这样我们只需要修改GitHub中的配置即可对所有的服务进行配置管理了。</p>
<h4 id="部署配置中心"><a href="#部署配置中心" class="headerlink" title="部署配置中心"></a>部署配置中心</h4><p>这里我们接着创建一个新的项目，并导入spring-cloud-config依赖和spring-cloud-starter-netflix-eureka-client（需要注册到Eureka才能生效）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>老规矩，启动类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ConfigApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着就是配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8700</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">configserver</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8801/eureka,</span> <span class="string">http://localhost:8802/eureka</span></span><br></pre></td></tr></table></figure>

<p>先启动一次看看，能不能成功：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0m9lyfoz2j226409uabs.jpg" alt="image-20220325173932623"></p>
<p>这里我们以本地仓库为例（就不用GitHub了，卡到怀疑人生了），首先在项目目录下创建一个本地Git仓库，打开终端，在桌面上创建一个新的本地仓库：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0mhe24rhjj211q05cabb.jpg" alt="image-20220325220843990"></p>
<p>然后我们在文件夹中随便创建一些配置文件，注意名称最好是{服务名称}-{环境}.yml：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0mhjqi2o6j216205gaan.jpg" alt="image-20220325221411834"></p>
<p>然后我们在配置文件中，添加本地仓库的一些信息（远程仓库同理），详细使用教程：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-cloud-config/docs/current/reference/html/#_git_backend">https://docs.spring.io/spring-cloud-config/docs/current/reference/html/#_git_backend</a></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">        	<span class="comment"># 这里填写的是本地仓库地址，远程仓库直接填写远程仓库地址 http://git...</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">file://$&#123;user.home&#125;/Desktop/config-repo</span></span><br><span class="line">          <span class="comment"># 默认分支设定为你自己本地或是远程分支的名称</span></span><br><span class="line">          <span class="attr">default-label:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>

<p>然后启动我们的配置服务器，通过以下格式进行访问：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://localhost:8700/%7B%E6%9C%8D%E5%8A%A1%E5%90%8D%E7%A7%B0%7D/%7B%E7%8E%AF%E5%A2%83%7D/%7BGit%E5%88%86%E6%94%AF%7D">http://localhost:8700/{服务名称}/{环境}/{Git分支}</a></li>
<li><a target="_blank" rel="noopener" href="http://localhost:8700/%7BGit%E5%88%86%E6%94%AF%7D/%7B%E6%9C%8D%E5%8A%A1%E5%90%8D%E7%A7%B0%7D-%7B%E7%8E%AF%E5%A2%83%7D.yml">http://localhost:8700/{Git分支}/{服务名称}-{环境}.yml</a></li>
</ul>
<p>比如我们要访问图书服务的生产环境代码，可以使用 <a target="_blank" rel="noopener" href="http://localhost:8700/bookservice/prod/main">http://localhost:8700/bookservice/prod/main</a> 链接，它会显示详细信息：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0mhpjeaiyj22is0cadjs.jpg" alt="image-20220325221946363"></p>
<p>也可以使用 <a target="_blank" rel="noopener" href="http://localhost:8700/main/bookservice-prod.yml">http://localhost:8700/main/bookservice-prod.yml</a> 链接，它仅显示配置文件原文：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0mht1siqdj21ro0hu41a.jpg" alt="image-20220325222309095"></p>
<h4 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h4><p>服务端配置完成之后，我们接着来配置一下客户端，那么现在我们的服务既然需要从服务器读取配置文件，那么就需要进行一些配置，我们删除原来的<code>application.yml</code>文件（也可以保留，最后无论是远端配置还是本地配置都会被加载），改用<code>bootstrap.yml</code>（在application.yml之前加载，可以实现配置文件远程获取）：</p>
<p>需要导入config的依赖 以及 bootstrap依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>客户端的配置<code>bootstrap.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">    	<span class="comment"># 名称，其实就是文件名称</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">bookservice</span></span><br><span class="line">      <span class="comment"># 配置服务器的地址</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://localhost:8700</span></span><br><span class="line">      <span class="comment"># 环境</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">prod</span></span><br><span class="line">      <span class="comment"># 分支</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>

<p>配置完成之后，启动图书服务：</p>
<p><img src="../images/SpringCloud%E7%AC%94%E8%AE%B0/e6c9d24ely1h0mii0tbegj22l208k43a.jpg" alt="image-20220325224708591"></p>
<p>可以看到已经从远端获取到了配置，并进行启动。</p>
<hr>
<h2 id="微服务CAP原则"><a href="#微服务CAP原则" class="headerlink" title="微服务CAP原则"></a>微服务CAP原则</h2><blockquote>
<p>CAP原则又称CAP定理，指的是在一个分布式系统中，存在Consistency（一致性）、Availability（可用性）、Partition tolerance（分区容错性），三者不可同时保证，最多只能保证其中的两者。   </p>
<p>一致性（C）：在分布式系统中的所有数据备份，在同一时刻都是同样的值（所有的节点无论何时访问都能拿到最新的值）</p>
<p>可用性（A）：系统中非故障节点收到的每个请求都必须得到响应（比如我们之前使用的服务降级和熔断，其实就是一种维持可用性的措施，虽然服务返回的是没有什么意义的数据，但是不至于用户的请求会被服务器忽略）</p>
<p>分区容错性（P）：一个分布式系统里面，节点之间组成的网络本来应该是连通的，然而可能因为一些故障（比如网络丢包等，这是很难避免的），使得有些节点之间不连通了，整个网络就分成了几块区域，数据就散布在了这些不连通的区域中（这样就可能出现某些被分区节点存放的数据访问失败，我们需要来容忍这些不可靠的情况）</p>
</blockquote>
<p>总的来说，数据存放的节点数越多，分区容忍性就越高，但是要复制更新的次数就越多，一致性就越难保证。同时为了保证一致性，更新所有节点数据所需要的时间就越长，那么可用性就会降低。</p>
<p>所以说，只能存在以下三种方案：</p>
<h3 id="AC-可用性-一致性"><a href="#AC-可用性-一致性" class="headerlink" title="AC 可用性+一致性"></a>AC 可用性+一致性</h3><p>要同时保证可用性和一致性，代表着某个节点数据更新之后，需要立即将结果通知给其他节点，并且要尽可能的快，这样才能及时响应保证可用性，这就对网络的稳定性要求非常高，但是实际情况下，网络很容易出现丢包等情况，并不是一个可靠的传输，如果需要避免这种问题，就只能将节点全部放在一起，但是这显然违背了分布式系统的概念，所以对于我们的分布式系统来说，很难接受。</p>
<h3 id="CP-一致性-分区容错性"><a href="#CP-一致性-分区容错性" class="headerlink" title="CP 一致性+分区容错性"></a>CP 一致性+分区容错性</h3><p>为了保证一致性，那么就得将某个节点的最新数据发送给其他节点，并且需要等到所有节点都得到数据才能进行响应，同时有了分区容错性，那么代表我们可以容忍网络的不可靠问题，所以就算网络出现卡顿，那么也必须等待所有节点完成数据同步，才能进行响应，因此就会<strong>导致服务在一段时间内完全失效，所以可用性是无法得到保证的</strong>。</p>
<h3 id="AP-可用性-分区容错性"><a href="#AP-可用性-分区容错性" class="headerlink" title="AP 可用性+分区容错性"></a>AP 可用性+分区容错性</h3><p>既然CP可能会导致一段时间内服务得不到任何响应，那么要保证可用性，就只能放弃节点之间数据的高度统一，也就是说<strong>可以在数据不统一的情况下，进行响应，因此就无法保证一致性了</strong>。虽然这样会导致拿不到最新的数据，但是只要数据同步操作在后台继续运行，一定能够在某一时刻完成所有节点数据的同步，那么就能实现<strong>最终一致性</strong>，所以<u>AP实际上是最能接受的一种方案</u>。</p>
<p>比如我们实现的<strong>Eureka集群，它使用的就是AP方案</strong>，Eureka各个节点都是平等的，少数节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka客户端在向某个Eureka服务端注册时如果发现连接失败，则会自动切换至其他节点。只要有一台Eureka服务器正常运行，那么就能保证服务可用<strong>（A）</strong>，只不过查询到的信息可能不是最新的<strong>（C）</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">lcq</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/post/67c8035e.html">http://example.com/post/67c8035e.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/SpringCloud/">SpringCloud</a></div><div class="post_share"><div class="social-share" data-image="https://iw233.cn/api.php?sort=pc" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> Donate</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg"/></a><div class="post-qr-code-desc"></div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg"/></a><div class="post-qr-code-desc"></div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/2a78d0be.html"><img class="prev-cover" src="https://iw233.cn/api.php?sort=pc" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">SpringCloud笔记（2）</div></div></a></div><div class="next-post pull-right"><a href="/post/be69454d.html"><img class="next-cover" src="https://iw233.cn/api.php?sort=pc" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">三、Android四大组件</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/post/2a78d0be.html" title="SpringCloud笔记（2）"><img class="cover" src="https://iw233.cn/api.php?sort=pc" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-26</div><div class="title">SpringCloud笔记（2）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">lcq</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/lcqlcqq" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">微服务基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E8%B5%B0%E8%BF%9BSpringCloud"><span class="toc-number">1.1.</span> <span class="toc-text">（1）走进SpringCloud</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89Eureka-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-number">1.2.</span> <span class="toc-text">（2）Eureka 注册中心</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.1.</span> <span class="toc-text">微服务结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%B0%83%E7%94%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">服务间调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0"><span class="toc-number">1.2.3.</span> <span class="toc-text">服务注册与发现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-number">1.2.4.</span> <span class="toc-text">注册中心高可用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89LoadBalancer-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">1.3.</span> <span class="toc-text">（3）LoadBalancer 负载均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">1.3.1.</span> <span class="toc-text">负载均衡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5"><span class="toc-number">1.3.2.</span> <span class="toc-text">自定义负载均衡策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OpenFeign%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">1.3.3.</span> <span class="toc-text">OpenFeign实现负载均衡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%884%EF%BC%89Hystrix-%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD"><span class="toc-number">1.4.</span> <span class="toc-text">（4）Hystrix 服务熔断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7"><span class="toc-number">1.4.1.</span> <span class="toc-text">服务降级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD"><span class="toc-number">1.4.2.</span> <span class="toc-text">服务熔断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OpenFeign%E5%AE%9E%E7%8E%B0%E9%99%8D%E7%BA%A7"><span class="toc-number">1.4.3.</span> <span class="toc-text">OpenFeign实现降级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Actuator%E7%9B%91%E6%8E%A7%E9%A1%B5%E9%9D%A2%E9%83%A8%E7%BD%B2"><span class="toc-number">1.4.4.</span> <span class="toc-text">Actuator监控页面部署</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%885%EF%BC%89Gateway-%E8%B7%AF%E7%94%B1%E7%BD%91%E5%85%B3"><span class="toc-number">1.5.</span> <span class="toc-text">（5）Gateway 路由网关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2%E7%BD%91%E5%85%B3"><span class="toc-number">1.5.1.</span> <span class="toc-text">部署网关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">1.5.2.</span> <span class="toc-text">路由过滤器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%886%EF%BC%89Config-%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83"><span class="toc-number">1.6.</span> <span class="toc-text">（6）Config 配置中心</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83"><span class="toc-number">1.6.1.</span> <span class="toc-text">部署配置中心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE"><span class="toc-number">1.6.2.</span> <span class="toc-text">客户端配置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1CAP%E5%8E%9F%E5%88%99"><span class="toc-number">2.</span> <span class="toc-text">微服务CAP原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AC-%E5%8F%AF%E7%94%A8%E6%80%A7-%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">2.1.</span> <span class="toc-text">AC 可用性+一致性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CP-%E4%B8%80%E8%87%B4%E6%80%A7-%E5%88%86%E5%8C%BA%E5%AE%B9%E9%94%99%E6%80%A7"><span class="toc-number">2.2.</span> <span class="toc-text">CP 一致性+分区容错性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AP-%E5%8F%AF%E7%94%A8%E6%80%A7-%E5%88%86%E5%8C%BA%E5%AE%B9%E9%94%99%E6%80%A7"><span class="toc-number">2.3.</span> <span class="toc-text">AP 可用性+分区容错性</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/2a78d0be.html" title="SpringCloud笔记（2）">SpringCloud笔记（2）</a><time datetime="2022-07-26T12:21:53.000Z" title="Created 2022-07-26 20:21:53">2022-07-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/67c8035e.html" title="SpringCloud笔记">SpringCloud笔记</a><time datetime="2022-07-23T07:04:04.000Z" title="Created 2022-07-23 15:04:04">2022-07-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/be69454d.html" title="三、Android四大组件">三、Android四大组件</a><time datetime="2022-07-22T15:15:31.000Z" title="Created 2022-07-22 23:15:31">2022-07-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/34811d5f.html" title="贪心">贪心</a><time datetime="2022-07-22T15:09:21.000Z" title="Created 2022-07-22 23:09:21">2022-07-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/9cbcbe19.html" title="二、UI与布局">二、UI与布局</a><time datetime="2022-07-18T09:47:46.000Z" title="Created 2022-07-18 17:47:46">2022-07-18</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By lcq</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>